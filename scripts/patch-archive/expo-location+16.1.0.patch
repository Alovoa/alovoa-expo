diff --git a/node_modules/expo-location/LICENSE b/node_modules/expo-location/LICENSE
new file mode 100644
index 0000000..30b20e3
--- /dev/null
+++ b/node_modules/expo-location/LICENSE
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2015-present 650 Industries, Inc. (aka Expo)
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/node_modules/expo-location/android/.gitignore b/node_modules/expo-location/android/.gitignore
new file mode 100755
index 0000000..72768b1
--- /dev/null
+++ b/node_modules/expo-location/android/.gitignore
@@ -0,0 +1,261 @@
+
+# Created by https://www.gitignore.io/api/java,maven,gradle,android,intellij,androidstudio
+
+### Android ###
+# Built application files
+*.apk
+*.ap_
+
+# Files for the ART/Dalvik VM
+*.dex
+
+# Java class files
+*.class
+
+# Generated files
+bin/
+gen/
+out/
+
+# Gradle files
+.gradle/
+build/
+
+# Local configuration file (sdk path, etc)
+local.properties
+
+# Proguard folder generated by Eclipse
+proguard/
+
+# Log Files
+*.log
+
+# Android Studio Navigation editor temp files
+.navigation/
+
+# Android Studio captures folder
+captures/
+
+# Intellij
+*.iml
+.idea/workspace.xml
+.idea/tasks.xml
+.idea/gradle.xml
+.idea/dictionaries
+.idea/libraries
+
+# External native build folder generated in Android Studio 2.2 and later
+.externalNativeBuild
+
+# Freeline
+freeline.py
+freeline/
+freeline_project_description.json
+
+### Android Patch ###
+gen-external-apklibs
+
+### AndroidStudio ###
+# Covers files to be ignored for android development using Android Studio.
+
+# Built application files
+
+# Files for the ART/Dalvik VM
+
+# Java class files
+
+# Generated files
+
+# Gradle files
+.gradle
+
+# Signing files
+.signing/
+
+# Local configuration file (sdk path, etc)
+
+# Proguard folder generated by Eclipse
+
+# Log Files
+
+# Android Studio
+/*/build/
+/*/local.properties
+/*/out
+/*/*/build
+/*/*/production
+*.ipr
+*~
+*.swp
+
+# Android Patch
+
+# External native build folder generated in Android Studio 2.2 and later
+
+# NDK
+obj/
+
+# IntelliJ IDEA
+*.iws
+/out/
+
+# User-specific configurations
+.idea/libraries/
+.idea/.name
+.idea/compiler.xml
+.idea/copyright/profiles_settings.xml
+.idea/encodings.xml
+.idea/misc.xml
+.idea/modules.xml
+.idea/scopes/scope_settings.xml
+.idea/vcs.xml
+.idea/jsLibraryMappings.xml
+.idea/datasources.xml
+.idea/dataSources.ids
+.idea/sqlDataSources.xml
+.idea/dynamic.xml
+.idea/uiDesigner.xml
+
+# OS-specific files
+.DS_Store
+.DS_Store?
+._*
+.Spotlight-V100
+.Trashes
+ehthumbs.db
+Thumbs.db
+
+# Legacy Eclipse project files
+.classpath
+.project
+.cproject
+.settings/
+
+# Mobile Tools for Java (J2ME)
+.mtj.tmp/
+
+# Package Files #
+*.war
+*.ear
+
+# virtual machine crash logs (Reference: http://www.java.com/en/download/help/error_hotspot.xml)
+hs_err_pid*
+
+## Plugin-specific files:
+
+# mpeltonen/sbt-idea plugin
+.idea_modules/
+
+# JIRA plugin
+atlassian-ide-plugin.xml
+
+# Mongo Explorer plugin
+.idea/mongoSettings.xml
+
+### AndroidStudio Patch ###
+
+!/gradle/wrapper/gradle-wrapper.jar
+
+### Intellij ###
+# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and Webstorm
+# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839
+
+# User-specific stuff:
+.idea/**/workspace.xml
+.idea/**/tasks.xml
+
+# Sensitive or high-churn files:
+.idea/**/dataSources/
+.idea/**/dataSources.ids
+.idea/**/dataSources.xml
+.idea/**/dataSources.local.xml
+.idea/**/sqlDataSources.xml
+.idea/**/dynamic.xml
+.idea/**/uiDesigner.xml
+
+# Gradle:
+.idea/**/gradle.xml
+.idea/**/libraries
+
+# CMake
+cmake-build-debug/
+
+# Mongo Explorer plugin:
+.idea/**/mongoSettings.xml
+
+## File-based project format:
+
+## Plugin-specific files:
+
+# IntelliJ
+
+# mpeltonen/sbt-idea plugin
+
+# JIRA plugin
+
+# Cursive Clojure plugin
+.idea/replstate.xml
+
+# Ruby plugin and RubyMine
+/.rakeTasks
+
+### Intellij Patch ###
+# Comment Reason: https://github.com/joeblau/gitignore.io/issues/186#issuecomment-215987721
+
+# *.iml
+# modules.xml
+# .idea/misc.xml
+# *.ipr
+
+# Sonarlint plugin
+.idea/sonarlint
+
+### Java ###
+# Compiled class file
+
+# Log file
+
+# BlueJ files
+*.ctxt
+
+# Mobile Tools for Java (J2ME)
+
+# Package Files #
+*.jar
+*.zip
+*.tar.gz
+*.rar
+
+# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
+
+### Maven ###
+target/
+pom.xml.tag
+pom.xml.releaseBackup
+pom.xml.versionsBackup
+pom.xml.next
+release.properties
+dependency-reduced-pom.xml
+buildNumber.properties
+.mvn/timing.properties
+
+# Avoid ignoring Maven wrapper jar file (.jar files are usually ignored)
+!/.mvn/wrapper/maven-wrapper.jar
+
+### Gradle ###
+**/build/
+
+# Ignore Gradle GUI config
+gradle-app.setting
+
+# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)
+!gradle-wrapper.jar
+
+# Cache of project
+.gradletasknamecache
+
+# # Work around https://youtrack.jetbrains.com/issue/IDEA-116898
+# gradle/wrapper/gradle-wrapper.properties
+
+
+# End of https://www.gitignore.io/api/java,maven,gradle,android,intellij,androidstudio
diff --git a/node_modules/expo-location/android/build.gradle b/node_modules/expo-location/android/build.gradle
index 190f8b4..233f33f 100644
--- a/node_modules/expo-location/android/build.gradle
+++ b/node_modules/expo-location/android/build.gradle
@@ -82,11 +82,5 @@ android {
 dependencies {
   implementation project(':expo-modules-core')
 
-  api 'com.google.android.gms:play-services-location:20.0.0'
-
-  api('io.nlopez.smartlocation:library:3.3.3') {
-    transitive = false
-  }
-
   implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:${getKotlinVersion()}"
 }
diff --git a/node_modules/expo-location/android/src/main/java/expo/modules/location/LocationHelpers.java b/node_modules/expo-location/android/src/main/java/expo/modules/location/LocationHelpers.java
index 24f8afd..9ce4323 100644
--- a/node_modules/expo-location/android/src/main/java/expo/modules/location/LocationHelpers.java
+++ b/node_modules/expo-location/android/src/main/java/expo/modules/location/LocationHelpers.java
@@ -10,15 +10,8 @@ import android.os.Bundle;
 import android.os.PersistableBundle;
 import android.util.Log;
 
-import com.google.android.gms.location.LocationRequest;
-
 import java.util.Map;
 
-import expo.modules.core.Promise;
-import expo.modules.core.errors.CodedException;
-import io.nlopez.smartlocation.location.config.LocationAccuracy;
-import io.nlopez.smartlocation.location.config.LocationParams;
-
 import static expo.modules.location.LocationModule.*;
 
 public class LocationHelpers {
@@ -119,78 +112,6 @@ public class LocationHelpers {
     return heading;
   }
 
-  public static LocationRequest prepareLocationRequest(Map<String, Object> options) {
-    LocationParams locationParams = LocationHelpers.mapOptionsToLocationParams(options);
-    int accuracy = LocationHelpers.getAccuracyFromOptions(options);
-
-    return new LocationRequest()
-        .setFastestInterval(locationParams.getInterval())
-        .setInterval(locationParams.getInterval())
-        .setMaxWaitTime(locationParams.getInterval())
-        .setSmallestDisplacement(locationParams.getDistance())
-        .setPriority(mapAccuracyToPriority(accuracy));
-  }
-
-  public static LocationParams mapOptionsToLocationParams(Map<String, Object> options) {
-    int accuracy = getAccuracyFromOptions(options);
-
-    LocationParams.Builder locationParamsBuilder = buildLocationParamsForAccuracy(accuracy);
-
-    if (options.containsKey("timeInterval")) {
-      Number timeInterval = (Number) options.get("timeInterval");
-      locationParamsBuilder.setInterval(timeInterval.longValue());
-    }
-    if (options.containsKey("distanceInterval")) {
-      Number distanceInterval = (Number) options.get("distanceInterval");
-      locationParamsBuilder.setDistance(distanceInterval.floatValue());
-    }
-    return locationParamsBuilder.build();
-  }
-
-  static void requestSingleLocation(final LocationModule locationModule, final LocationRequest locationRequest, final Promise promise) {
-    // we want just one update
-    locationRequest.setNumUpdates(1);
-
-    locationModule.requestLocationUpdates(locationRequest, null, new LocationRequestCallbacks() {
-      @Override
-      public void onLocationChanged(Location location) {
-        promise.resolve(LocationHelpers.locationToBundle(location, Bundle.class));
-      }
-
-      @Override
-      public void onLocationError(CodedException exception) {
-        promise.reject(exception);
-      }
-
-      @Override
-      public void onRequestFailed(CodedException exception) {
-        promise.reject(exception);
-      }
-    });
-  }
-
-  static void requestContinuousUpdates(final LocationModule locationModule, final LocationRequest locationRequest, final int watchId, final Promise promise) {
-    locationModule.requestLocationUpdates(locationRequest, watchId, new LocationRequestCallbacks() {
-      @Override
-      public void onLocationChanged(Location location) {
-        Bundle response = new Bundle();
-
-        response.putBundle("location", LocationHelpers.locationToBundle(location, Bundle.class));
-        locationModule.sendLocationResponse(watchId, response);
-      }
-
-      @Override
-      public void onRequestSuccess() {
-        promise.resolve(null);
-      }
-
-      @Override
-      public void onRequestFailed(CodedException exception) {
-        promise.reject(exception);
-      }
-    });
-  }
-
   /**
    * Checks whether given location didn't exceed given `maxAge` and fits in the required accuracy.
    */
@@ -212,56 +133,5 @@ public class LocationHelpers {
     return options.containsKey("accuracy") ? ((Number) options.get("accuracy")).intValue() : ACCURACY_BALANCED;
   }
 
-  private static LocationParams.Builder buildLocationParamsForAccuracy(int accuracy) {
-    switch (accuracy) {
-      case ACCURACY_LOWEST:
-        return new LocationParams.Builder()
-            .setAccuracy(LocationAccuracy.LOWEST)
-            .setDistance(3000)
-            .setInterval(10000);
-      case ACCURACY_LOW:
-        return new LocationParams.Builder()
-            .setAccuracy(LocationAccuracy.LOW)
-            .setDistance(1000)
-            .setInterval(5000);
-      case ACCURACY_BALANCED:
-      default:
-        return new LocationParams.Builder()
-            .setAccuracy(LocationAccuracy.MEDIUM)
-            .setDistance(100)
-            .setInterval(3000);
-      case ACCURACY_HIGH:
-        return new LocationParams.Builder()
-            .setAccuracy(LocationAccuracy.HIGH)
-            .setDistance(50)
-            .setInterval(2000);
-      case ACCURACY_HIGHEST:
-        return new LocationParams.Builder()
-            .setAccuracy(LocationAccuracy.HIGH)
-            .setDistance(25)
-            .setInterval(1000);
-      case ACCURACY_BEST_FOR_NAVIGATION:
-        return new LocationParams.Builder()
-            .setAccuracy(LocationAccuracy.HIGH)
-            .setDistance(0)
-            .setInterval(500);
-    }
-  }
-
-  private static int mapAccuracyToPriority(int accuracy) {
-    switch (accuracy) {
-      case LocationModule.ACCURACY_BEST_FOR_NAVIGATION:
-      case LocationModule.ACCURACY_HIGHEST:
-      case LocationModule.ACCURACY_HIGH:
-        return LocationRequest.PRIORITY_HIGH_ACCURACY;
-      case LocationModule.ACCURACY_BALANCED:
-      case LocationModule.ACCURACY_LOW:
-      default:
-        return LocationRequest.PRIORITY_BALANCED_POWER_ACCURACY;
-      case LocationModule.ACCURACY_LOWEST:
-        return LocationRequest.PRIORITY_LOW_POWER;
-    }
-  }
-
   //endregion
 }
diff --git a/node_modules/expo-location/android/src/main/java/expo/modules/location/LocationModule.java b/node_modules/expo-location/android/src/main/java/expo/modules/location/LocationModule.java
index 8eb894a..efd9eb5 100644
--- a/node_modules/expo-location/android/src/main/java/expo/modules/location/LocationModule.java
+++ b/node_modules/expo-location/android/src/main/java/expo/modules/location/LocationModule.java
@@ -3,40 +3,24 @@
 package expo.modules.location;
 
 import android.Manifest;
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
-import android.content.IntentSender;
 import android.hardware.GeomagneticField;
-import android.location.Address;
-import android.location.Geocoder;
 import android.location.Location;
 import android.hardware.Sensor;
 import android.hardware.SensorEvent;
 import android.hardware.SensorEventListener;
 import android.hardware.SensorManager;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.location.LocationProvider;
+import android.location.LocationRequest;
 import android.os.Build;
 import android.os.Bundle;
-import android.os.Looper;
-
-import android.util.Log;
-
-import com.google.android.gms.common.api.ApiException;
-import com.google.android.gms.common.api.CommonStatusCodes;
-import com.google.android.gms.common.api.ResolvableApiException;
-import com.google.android.gms.location.FusedLocationProviderClient;
-import com.google.android.gms.location.LocationAvailability;
-import com.google.android.gms.location.LocationCallback;
-import com.google.android.gms.location.LocationRequest;
-import com.google.android.gms.location.LocationResult;
-import com.google.android.gms.location.LocationServices;
-import com.google.android.gms.location.LocationSettingsRequest;
-import com.google.android.gms.location.LocationSettingsResponse;
-import com.google.android.gms.location.SettingsClient;
-import com.google.android.gms.tasks.Task;
 
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -51,6 +35,7 @@ import expo.modules.core.interfaces.LifecycleEventListener;
 import expo.modules.core.interfaces.services.EventEmitter;
 import expo.modules.core.interfaces.services.UIManager;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.RequiresApi;
 
 import expo.modules.interfaces.permissions.Permissions;
@@ -58,38 +43,17 @@ import expo.modules.interfaces.permissions.PermissionsResponse;
 import expo.modules.interfaces.permissions.PermissionsStatus;
 import expo.modules.interfaces.taskManager.TaskManagerInterface;
 import expo.modules.location.exceptions.LocationBackgroundUnauthorizedException;
-import expo.modules.location.exceptions.LocationRequestRejectedException;
-import expo.modules.location.exceptions.LocationSettingsUnsatisfiedException;
 import expo.modules.location.exceptions.LocationUnauthorizedException;
-import expo.modules.location.exceptions.LocationUnavailableException;
 import expo.modules.location.taskConsumers.GeofencingTaskConsumer;
 import expo.modules.location.taskConsumers.LocationTaskConsumer;
-import io.nlopez.smartlocation.SmartLocation;
-import io.nlopez.smartlocation.geocoding.utils.LocationAddress;
-import io.nlopez.smartlocation.location.config.LocationParams;
-import io.nlopez.smartlocation.location.utils.LocationState;
 
 public class LocationModule extends ExportedModule implements LifecycleEventListener, SensorEventListener, ActivityEventListener {
-  private static final String TAG = LocationModule.class.getSimpleName();
   private static final String LOCATION_EVENT_NAME = "Expo.locationChanged";
   private static final String HEADING_EVENT_NAME = "Expo.headingChanged";
   private static final int CHECK_SETTINGS_REQUEST_CODE = 42;
-
-  private static final String SHOW_USER_SETTINGS_DIALOG_KEY = "mayShowUserSettingsDialog";
-
-  public static final int ACCURACY_LOWEST = 1;
-  public static final int ACCURACY_LOW = 2;
   public static final int ACCURACY_BALANCED = 3;
-  public static final int ACCURACY_HIGH = 4;
-  public static final int ACCURACY_HIGHEST = 5;
-  public static final int ACCURACY_BEST_FOR_NAVIGATION = 6;
 
-  public static final int GEOFENCING_EVENT_ENTER = 1;
-  public static final int GEOFENCING_EVENT_EXIT = 2;
-
-  public static final int GEOFENCING_REGION_STATE_UNKNOWN = 0;
-  public static final int GEOFENCING_REGION_STATE_INSIDE = 1;
-  public static final int GEOFENCING_REGION_STATE_OUTSIDE = 2;
+  private LocationManager locationManager;
 
   public interface OnResultListener {
     void onResult(Location location);
@@ -98,10 +62,8 @@ public class LocationModule extends ExportedModule implements LifecycleEventList
   private Context mContext;
   private SensorManager mSensorManager;
   private GeomagneticField mGeofield;
-  private FusedLocationProviderClient mLocationProvider;
+  private LocationProvider mLocationProvider;
 
-  private Map<Integer, LocationCallback> mLocationCallbacks = new HashMap<>();
-  private Map<Integer, LocationRequest> mLocationRequests = new HashMap<>();
   private List<LocationActivityResultListener> mPendingLocationRequests = new ArrayList<>();
 
   // modules
@@ -249,34 +211,13 @@ public class LocationModule extends ExportedModule implements LifecycleEventList
     }, Manifest.permission.ACCESS_BACKGROUND_LOCATION);
   }
 
-  /**
-   * Resolves to the last known position if it is available and matches given requirements or null otherwise.
-   */
-  @ExpoMethod
-  public void getLastKnownPositionAsync(final Map<String, Object> options, final Promise promise) {
-    // Check for permissions
-    if (isMissingForegroundPermissions()) {
-      promise.reject(new LocationUnauthorizedException());
-      return;
-    }
-    getLastKnownLocation(location -> {
-      if (LocationHelpers.isLocationValid(location, options)) {
-        promise.resolve(LocationHelpers.locationToBundle(location, Bundle.class));
-      } else {
-        promise.resolve(null);
-      }
-    });
-  }
-
   /**
    * Requests for the current position. Depending on given accuracy, it may take some time to resolve.
    * If you don't need an up-to-date location see `getLastKnownPosition`.
    */
+  @SuppressLint("MissingPermission")
   @ExpoMethod
   public void getCurrentPositionAsync(final Map<String, Object> options, final Promise promise) {
-    // Read options
-    final LocationRequest locationRequest = LocationHelpers.prepareLocationRequest(options);
-    boolean showUserSettingsDialog = !options.containsKey(SHOW_USER_SETTINGS_DIALOG_KEY) || (boolean) options.get(SHOW_USER_SETTINGS_DIALOG_KEY);
 
     // Check for permissions
     if (isMissingForegroundPermissions()) {
@@ -284,38 +225,38 @@ public class LocationModule extends ExportedModule implements LifecycleEventList
       return;
     }
 
-    if (LocationHelpers.hasNetworkProviderEnabled(mContext) || !showUserSettingsDialog) {
-      LocationHelpers.requestSingleLocation(this, locationRequest, promise);
-    } else {
-      // Pending requests can ask the user to turn on improved accuracy mode in user's settings.
-      addPendingLocationRequest(locationRequest, resultCode -> {
-        if (resultCode == Activity.RESULT_OK) {
-          LocationHelpers.requestSingleLocation(LocationModule.this, locationRequest, promise);
-        } else {
-          promise.reject(new LocationSettingsUnsatisfiedException());
-        }
-      });
+    if(locationManager == null) {
+      locationManager = (LocationManager) mContext.getSystemService(Context.LOCATION_SERVICE);
     }
-  }
 
-  @ExpoMethod
-  public void getProviderStatusAsync(final Promise promise) {
-    if (mContext == null) {
-      promise.reject("E_CONTEXT_UNAVAILABLE", "Context is not available");
-      return;
-    }
+    LocationListener locationListener = new LocationListener() {
 
-    LocationState state = SmartLocation.with(mContext).location().state();
+      boolean promiseResolved = false;
+      @Override
+      public void onLocationChanged(@NonNull Location location) {
+        if(!promiseResolved) {
+          promiseResolved = true;
+          promise.resolve(LocationHelpers.locationToBundle(location, Bundle.class));
+        }
+      }
+
+      @Override
+      public void onProviderDisabled(String provider) {}
+
+      @Override
+      public void onProviderEnabled(String provider) {}
+
+      @Override
+      public void onStatusChanged(String provider, int status, Bundle extras) {}
+    };
 
-    Bundle map = new Bundle();
+    locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);
+    locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, locationListener);
+  }
 
-    map.putBoolean("locationServicesEnabled", state.locationServicesEnabled()); // If location is off
-    map.putBoolean("gpsAvailable", state.isGpsAvailable()); // If GPS provider is enabled
-    map.putBoolean("networkAvailable", state.isNetworkAvailable()); // If network provider is enabled
-    map.putBoolean("passiveAvailable", state.isPassiveAvailable()); // If passive provider is enabled
-    map.putBoolean("backgroundModeEnabled", state.locationServicesEnabled()); // background mode is always available if location services are on
+  @ExpoMethod
+  public void getProviderStatusAsync(final Promise promise) {
 
-    promise.resolve(map);
   }
 
   // Start Compass Module
@@ -330,27 +271,7 @@ public class LocationModule extends ExportedModule implements LifecycleEventList
 
   @ExpoMethod
   public void watchPositionImplAsync(final int watchId, final Map<String, Object> options, final Promise promise) {
-    // Check for permissions
-    if (isMissingForegroundPermissions()) {
-      promise.reject(new LocationUnauthorizedException());
-      return;
-    }
-
-    final LocationRequest locationRequest = LocationHelpers.prepareLocationRequest(options);
-    boolean showUserSettingsDialog = !options.containsKey(SHOW_USER_SETTINGS_DIALOG_KEY) || (boolean) options.get(SHOW_USER_SETTINGS_DIALOG_KEY);
 
-    if (LocationHelpers.hasNetworkProviderEnabled(mContext) || !showUserSettingsDialog) {
-      LocationHelpers.requestContinuousUpdates(this, locationRequest, watchId, promise);
-    } else {
-      // Pending requests can ask the user to turn on improved accuracy mode in user's settings.
-      addPendingLocationRequest(locationRequest, resultCode -> {
-        if (resultCode == Activity.RESULT_OK) {
-          LocationHelpers.requestContinuousUpdates(LocationModule.this, locationRequest, watchId, promise);
-        } else {
-          promise.reject(new LocationSettingsUnsatisfiedException());
-        }
-      });
-    }
   }
 
   @ExpoMethod
@@ -372,86 +293,16 @@ public class LocationModule extends ExportedModule implements LifecycleEventList
 
   @ExpoMethod
   public void geocodeAsync(final String address, final Promise promise) {
-    if (mGeocoderPaused) {
-      promise.reject("E_CANNOT_GEOCODE", "Geocoder is not running.");
-      return;
-    }
 
-    if (isMissingForegroundPermissions()) {
-      promise.reject(new LocationUnauthorizedException());
-      return;
-    }
-
-    if (Geocoder.isPresent()) {
-      SmartLocation.with(mContext).geocoding()
-        .direct(address, (s, list) -> {
-          List<Bundle> results = new ArrayList<>(list.size());
-
-          for (LocationAddress locationAddress : list) {
-            Bundle coords = LocationHelpers.locationToCoordsBundle(locationAddress.getLocation(), Bundle.class);
-
-            if (coords != null) {
-              results.add(coords);
-            }
-          }
-
-          SmartLocation.with(mContext).geocoding().stop();
-          promise.resolve(results);
-        });
-    } else {
-      promise.reject("E_NO_GEOCODER", "Geocoder service is not available for this device.");
-    }
   }
 
   @ExpoMethod
   public void reverseGeocodeAsync(final Map<String, Object> locationMap, final Promise promise) {
-    if (mGeocoderPaused) {
-      promise.reject("E_CANNOT_GEOCODE", "Geocoder is not running.");
-      return;
-    }
-
-    if (isMissingForegroundPermissions()) {
-      promise.reject(new LocationUnauthorizedException());
-      return;
-    }
-
-    Location location = new Location("");
-    location.setLatitude((double) locationMap.get("latitude"));
-    location.setLongitude((double) locationMap.get("longitude"));
-
-    if (Geocoder.isPresent()) {
-      SmartLocation.with(mContext).geocoding()
-        .reverse(location, (original, addresses) -> {
-          List<Bundle> results = new ArrayList<>(addresses.size());
-
-          for (Address address : addresses) {
-            results.add(LocationHelpers.addressToBundle(address));
-          }
-
-          SmartLocation.with(mContext).geocoding().stop();
-          promise.resolve(results);
-        });
-    } else {
-      promise.reject("E_NO_GEOCODER", "Geocoder service is not available for this device.");
-    }
   }
 
   @ExpoMethod
   public void enableNetworkProviderAsync(final Promise promise) {
-    if (LocationHelpers.hasNetworkProviderEnabled(mContext)) {
-      promise.resolve(null);
-      return;
-    }
 
-    LocationRequest locationRequest = LocationHelpers.prepareLocationRequest(new HashMap<>());
-
-    addPendingLocationRequest(locationRequest, resultCode -> {
-      if (resultCode == Activity.RESULT_OK) {
-        promise.resolve(null);
-      } else {
-        promise.reject(new LocationSettingsUnsatisfiedException());
-      }
-    });
   }
 
   @ExpoMethod
@@ -545,39 +396,6 @@ public class LocationModule extends ExportedModule implements LifecycleEventList
   //region public methods
 
   void requestLocationUpdates(final LocationRequest locationRequest, Integer requestId, final LocationRequestCallbacks callbacks) {
-    final FusedLocationProviderClient locationProvider = getLocationProvider();
-
-    LocationCallback locationCallback = new LocationCallback() {
-      boolean isLocationAvailable = false;
-      @Override
-      public void onLocationResult(LocationResult locationResult) {
-        Location location = locationResult != null ? locationResult.getLastLocation() : null;
-
-        if (location != null) {
-          callbacks.onLocationChanged(location);
-        } else if (!isLocationAvailable) {
-          callbacks.onLocationError(new LocationUnavailableException());
-        }
-      }
-
-      @Override
-      public void onLocationAvailability(LocationAvailability locationAvailability) {
-        isLocationAvailable = locationAvailability.isLocationAvailable();
-      }
-    };
-
-    if (requestId != null) {
-      // Save location callback and request so we will be able to pause/resume receiving updates.
-      mLocationCallbacks.put(requestId, locationCallback);
-      mLocationRequests.put(requestId, locationRequest);
-    }
-
-    try {
-      locationProvider.requestLocationUpdates(locationRequest, locationCallback, Looper.myLooper());
-      callbacks.onRequestSuccess();
-    } catch (SecurityException e) {
-      callbacks.onRequestFailed(new LocationRequestRejectedException(e));
-    }
   }
 
   //region private methods
@@ -602,30 +420,6 @@ public class LocationModule extends ExportedModule implements LifecycleEventList
       (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && !mPermissionsManager.hasGrantedPermissions(Manifest.permission.ACCESS_BACKGROUND_LOCATION));
   }
 
-  /**
-   * Helper method that lazy-loads the location provider for the context that the module was created.
-   */
-  private FusedLocationProviderClient getLocationProvider() {
-    if (mLocationProvider == null) {
-      mLocationProvider = LocationServices.getFusedLocationProviderClient(mContext);
-    }
-    return mLocationProvider;
-  }
-
-  /**
-   * Gets the best most recent location found by the provider.
-   */
-  private void getLastKnownLocation(final OnResultListener callback) {
-    try {
-      getLocationProvider().getLastLocation()
-        .addOnSuccessListener(location -> callback.onResult(location))
-        .addOnCanceledListener(() -> callback.onResult(null))
-        .addOnFailureListener(exception -> callback.onResult(null));
-    } catch (SecurityException e) {
-      callback.onResult(null);
-    }
-  }
-
   private void addPendingLocationRequest(LocationRequest locationRequest, LocationActivityResultListener listener) {
     // Add activity result listener to an array of pending requests.
     mPendingLocationRequests.add(listener);
@@ -640,74 +434,19 @@ public class LocationModule extends ExportedModule implements LifecycleEventList
    * Triggers system's dialog to ask the user to enable settings required for given location request.
    */
   private void resolveUserSettingsForRequest(LocationRequest locationRequest) {
-    final Activity activity = mActivityProvider.getCurrentActivity();
 
-    if (activity == null) {
-      // Activity not found. It could have been called in a headless mode.
-      executePendingRequests(Activity.RESULT_CANCELED);
-      return;
-    }
-
-    LocationSettingsRequest.Builder builder = new LocationSettingsRequest.Builder().addLocationRequest(locationRequest);
-    SettingsClient client = LocationServices.getSettingsClient(mContext);
-    Task<LocationSettingsResponse> task = client.checkLocationSettings(builder.build());
-
-    task.addOnSuccessListener(locationSettingsResponse -> {
-      // All location settings requirements are satisfied.
-      executePendingRequests(Activity.RESULT_OK);
-    });
-
-    task.addOnFailureListener(e -> {
-      int statusCode = ((ApiException) e).getStatusCode();
-
-      if (statusCode == CommonStatusCodes.RESOLUTION_REQUIRED) {
-        // Location settings are not satisfied, but this can be fixed by showing the user a dialog.
-        // Show the dialog by calling startResolutionForResult(), and check the result in onActivityResult().
-
-        try {
-          ResolvableApiException resolvable = (ResolvableApiException) e;
-
-          mUIManager.registerActivityEventListener(LocationModule.this);
-          resolvable.startResolutionForResult(activity, CHECK_SETTINGS_REQUEST_CODE);
-        } catch (IntentSender.SendIntentException sendEx) {
-          // Ignore the error.
-          executePendingRequests(Activity.RESULT_CANCELED);
-        }
-      } else {// Location settings are not satisfied. However, we have no way to fix the settings so we won't show the dialog.
-        executePendingRequests(Activity.RESULT_CANCELED);
-      }
-    });
   }
 
   private void pauseLocationUpdatesForRequest(Integer requestId) {
-    LocationCallback locationCallback = mLocationCallbacks.get(requestId);
 
-    if (locationCallback != null) {
-      getLocationProvider().removeLocationUpdates(locationCallback);
-    }
   }
 
   private void resumeLocationUpdates() {
-    final FusedLocationProviderClient locationClient = getLocationProvider();
 
-    for (Integer requestId : mLocationCallbacks.keySet()) {
-      LocationCallback locationCallback = mLocationCallbacks.get(requestId);
-      LocationRequest locationRequest = mLocationRequests.get(requestId);
-
-      if (locationCallback != null && locationRequest != null) {
-        try {
-          locationClient.requestLocationUpdates(locationRequest, locationCallback, Looper.myLooper());
-        } catch (SecurityException e) {
-          Log.e(TAG, "Error occurred while resuming location updates: " + e.toString());
-        }
-      }
-    }
   }
 
   private void removeLocationUpdatesForRequest(Integer requestId) {
-    pauseLocationUpdatesForRequest(requestId);
-    mLocationCallbacks.remove(requestId);
-    mLocationRequests.remove(requestId);
+
   }
 
   void sendLocationResponse(int watchId, Bundle response) {
@@ -724,28 +463,7 @@ public class LocationModule extends ExportedModule implements LifecycleEventList
   }
 
   private void startHeadingUpdate() {
-    if (mSensorManager == null || mContext == null) {
-      return;
-    }
 
-    SmartLocation.LocationControl locationControl = SmartLocation.with(mContext).location().oneFix().config(LocationParams.BEST_EFFORT);
-    Location currLoc = locationControl.getLastLocation();
-    if (currLoc != null) {
-      mGeofield = new GeomagneticField(
-        (float) currLoc.getLatitude(),
-        (float) currLoc.getLongitude(),
-        (float) currLoc.getAltitude(),
-        System.currentTimeMillis());
-    } else {
-      locationControl.start(location -> mGeofield = new GeomagneticField(
-        (float) location.getLatitude(),
-        (float) location.getLongitude(),
-        (float) location.getAltitude(),
-        System.currentTimeMillis()));
-    }
-    mSensorManager.registerListener(this, mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD),
-      SensorManager.SENSOR_DELAY_NORMAL);
-    mSensorManager.registerListener(this, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL);
   }
 
   private void sendUpdate() {
@@ -826,16 +544,6 @@ public class LocationModule extends ExportedModule implements LifecycleEventList
     if (mContext == null) {
       return;
     }
-
-    // if permissions not granted it won't work anyway, but this can be invoked when permission dialog appears
-    if (Geocoder.isPresent() && !isMissingForegroundPermissions()) {
-      SmartLocation.with(mContext).geocoding().stop();
-      mGeocoderPaused = true;
-    }
-
-    for (Integer requestId : mLocationCallbacks.keySet()) {
-      pauseLocationUpdatesForRequest(requestId);
-    }
   }
 
   private Bundle handleForegroundLocationPermissions(Map<String, PermissionsResponse> result) {
diff --git a/node_modules/expo-location/android/src/main/java/expo/modules/location/taskConsumers/GeofencingTaskConsumer.java b/node_modules/expo-location/android/src/main/java/expo/modules/location/taskConsumers/GeofencingTaskConsumer.java
index 7848874..fd9198a 100644
--- a/node_modules/expo-location/android/src/main/java/expo/modules/location/taskConsumers/GeofencingTaskConsumer.java
+++ b/node_modules/expo-location/android/src/main/java/expo/modules/location/taskConsumers/GeofencingTaskConsumer.java
@@ -1,288 +1,28 @@
 package expo.modules.location.taskConsumers;
 
-import android.app.PendingIntent;
-import android.app.job.JobParameters;
-import android.app.job.JobService;
 import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.os.PersistableBundle;
-import android.util.Log;
-
-import com.google.android.gms.location.Geofence;
-import com.google.android.gms.location.GeofenceStatusCodes;
-import com.google.android.gms.location.GeofencingClient;
-import com.google.android.gms.location.GeofencingEvent;
-import com.google.android.gms.location.GeofencingRequest;
-import com.google.android.gms.location.LocationServices;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
-
-import expo.modules.location.LocationHelpers;
-import expo.modules.location.LocationModule;
 import expo.modules.interfaces.taskManager.TaskConsumer;
 import expo.modules.interfaces.taskManager.TaskConsumerInterface;
-import expo.modules.interfaces.taskManager.TaskExecutionCallback;
 import expo.modules.interfaces.taskManager.TaskInterface;
 import expo.modules.interfaces.taskManager.TaskManagerUtilsInterface;
 
 public class GeofencingTaskConsumer extends TaskConsumer implements TaskConsumerInterface {
-  public static int VERSION = 1;
-
-  private static final String TAG = "GeofencingTaskConsumer";
-
-  private TaskInterface mTask;
-  private PendingIntent mPendingIntent;
-  private GeofencingClient mGeofencingClient;
-  private GeofencingRequest mGeofencingRequest;
-  private List<Geofence> mGeofencingList;
-  private Map<String, PersistableBundle> mRegions;
 
   public GeofencingTaskConsumer(Context context, TaskManagerUtilsInterface taskManagerUtils) {
     super(context, taskManagerUtils);
   }
 
-  //region TaskConsumerInterface
-
+  @Override
   public String taskType() {
-    return "geofencing";
+    return null;
   }
 
   @Override
-  @SuppressWarnings("unchecked")
   public void didRegister(TaskInterface task) {
-    if (task == null) {
-      return;
-    }
-    mTask = task;
-    startGeofencing();
   }
 
   @Override
   public void didUnregister() {
-    stopGeofencing();
-    mTask = null;
-    mPendingIntent = null;
-    mGeofencingClient = null;
-    mGeofencingRequest = null;
-    mGeofencingList = null;
-  }
-
-  @Override
-  public void setOptions(Map<String, Object> options) {
-    super.setOptions(options);
-    stopGeofencing();
-    startGeofencing();
-  }
-
-  @Override
-  public void didReceiveBroadcast(Intent intent) {
-    GeofencingEvent event = GeofencingEvent.fromIntent(intent);
-
-    if (event.hasError()) {
-      String errorMessage = getErrorString(event.getErrorCode());
-      Error error = new Error(errorMessage);
-      mTask.execute(null, error);
-      return;
-    }
-
-    // Get region state and event type from given transition type.
-    int geofenceTransition = event.getGeofenceTransition();
-    int regionState = regionStateForTransitionType(geofenceTransition);
-    int eventType = eventTypeFromTransitionType(geofenceTransition);
-
-    // Get the geofences that were triggered. A single event can trigger multiple geofences.
-    List<Geofence> triggeringGeofences = event.getTriggeringGeofences();
-
-    for (Geofence geofence : triggeringGeofences) {
-      PersistableBundle region = mRegions.get(geofence.getRequestId());
-
-      if (region != null) {
-        PersistableBundle data = new PersistableBundle();
-
-        // Update region state in region bundle.
-        region.putInt("state", regionState);
-
-        data.putInt("eventType", eventType);
-        data.putPersistableBundle("region", region);
-
-        Context context = getContext().getApplicationContext();
-        getTaskManagerUtils().scheduleJob(context, mTask, Collections.singletonList(data));
-      }
-    }
-  }
-
-  @Override
-  public boolean didExecuteJob(JobService jobService, JobParameters params) {
-    if (mTask == null) {
-      return false;
-    }
-
-
-    List<PersistableBundle> data = getTaskManagerUtils().extractDataFromJobParams(params);
-
-    for (PersistableBundle item : data) {
-      Bundle bundle = new Bundle();
-      Bundle region = new Bundle();
-
-      region.putAll(item.getPersistableBundle("region"));
-      bundle.putInt("eventType", item.getInt("eventType"));
-      bundle.putBundle("region", region);
-      if (mTask == null) {
-        return false;
-      }
-      mTask.execute(bundle, null, new TaskExecutionCallback() {
-        @Override
-        public void onFinished(Map<String, Object> response) {
-          jobService.jobFinished(params, false);
-        }
-      });
-    }
-
-    // Returning `true` indicates that the job is still running, but in async mode.
-    // In that case we're obligated to call `jobService.jobFinished` as soon as the async block finishes.
-    return true;
-  }
-
-  //endregion
-  //region helpers
-
-  private void startGeofencing() {
-    Context context = getContext();
-
-    if (context == null) {
-      Log.w(TAG, "The context has been abandoned.");
-      return;
-    }
-    if (!LocationHelpers.isAnyProviderAvailable(context)) {
-      Log.w(TAG, "There is no location provider available.");
-      return;
-    }
-
-    mRegions = new HashMap<>();
-    mGeofencingList = new ArrayList<>();
-
-    // Create geofences from task options.
-    Map<String, Object> options = mTask.getOptions();
-    List<HashMap<String, Object>> regions = (ArrayList<HashMap<String, Object>>) options.get("regions");
-
-    for (Map<String, Object> region : regions) {
-      Geofence geofence = geofenceFromRegion(region);
-      String regionIdentifier = geofence.getRequestId();
-
-      // Make a bundle for the region to remember its attributes. Only request ID is public in Geofence object.
-      mRegions.put(regionIdentifier, bundleFromRegion(regionIdentifier, region));
-
-      // Add geofence to the list of observed regions.
-      mGeofencingList.add(geofence);
-    }
-
-    // Prepare pending intent, geofencing request and client.
-    mPendingIntent = preparePendingIntent();
-    mGeofencingRequest = prepareGeofencingRequest(mGeofencingList);
-    mGeofencingClient = LocationServices.getGeofencingClient(getContext());
-
-    try {
-      mGeofencingClient.addGeofences(mGeofencingRequest, mPendingIntent);
-    } catch (SecurityException e) {
-      Log.w(TAG, "Geofencing request has been rejected.", e);
-    }
-  }
-
-  private void stopGeofencing() {
-    if (mGeofencingClient != null && mPendingIntent != null) {
-      mGeofencingClient.removeGeofences(mPendingIntent);
-      mPendingIntent.cancel();
-    }
-  }
-
-  private GeofencingRequest prepareGeofencingRequest(List<Geofence> geofences) {
-    return new GeofencingRequest.Builder()
-        .setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER | GeofencingRequest.INITIAL_TRIGGER_EXIT)
-        .addGeofences(geofences)
-        .build();
-  }
-
-  private PendingIntent preparePendingIntent() {
-    return getTaskManagerUtils().createTaskIntent(getContext(), mTask);
-  }
-
-  private Geofence geofenceFromRegion(Map<String, Object> region) {
-    String identifier = region.containsKey("identifier") ? (String) region.get("identifier") : UUID.randomUUID().toString();
-    double latitude = doubleFromObject(region.get("latitude"));
-    double longitude = doubleFromObject(region.get("longitude"));
-    double radius = doubleFromObject(region.get("radius"));
-
-    boolean notifyOnEnter = !region.containsKey("notifyOnEnter") || (boolean) region.get("notifyOnEnter");
-    boolean notifyOnExit = !region.containsKey("notifyOnExit") || (boolean) region.get("notifyOnExit");
-    int transitionTypes = (notifyOnEnter ? Geofence.GEOFENCE_TRANSITION_ENTER : 0) | (notifyOnExit ? Geofence.GEOFENCE_TRANSITION_EXIT : 0);
-
-    return new Geofence.Builder()
-        .setRequestId(identifier)
-        .setCircularRegion(latitude, longitude, (float) radius)
-        .setExpirationDuration(Geofence.NEVER_EXPIRE)
-        .setTransitionTypes(transitionTypes)
-        .build();
-  }
-
-  private PersistableBundle bundleFromRegion(String identifier, Map<String, Object> region) {
-    PersistableBundle bundle = new PersistableBundle();
-
-    bundle.putString("identifier", identifier);
-    bundle.putDouble("radius", doubleFromObject(region.get("radius")));
-    bundle.putDouble("latitude", doubleFromObject(region.get("latitude")));
-    bundle.putDouble("longitude", doubleFromObject(region.get("longitude")));
-    bundle.putInt("state", LocationModule.GEOFENCING_REGION_STATE_UNKNOWN);
-
-    return bundle;
-  }
-
-  private static double doubleFromObject(Object object) {
-    if (object instanceof Integer) {
-      return ((Integer) object).doubleValue();
-    }
-    return (Double) object;
-  }
-
-  private int regionStateForTransitionType(int transitionType) {
-    switch (transitionType) {
-      case Geofence.GEOFENCE_TRANSITION_ENTER:
-      case Geofence.GEOFENCE_TRANSITION_DWELL:
-        return LocationModule.GEOFENCING_REGION_STATE_INSIDE;
-      case Geofence.GEOFENCE_TRANSITION_EXIT:
-        return LocationModule.GEOFENCING_REGION_STATE_OUTSIDE;
-      default:
-        return LocationModule.GEOFENCING_REGION_STATE_UNKNOWN;
-    }
-  }
-
-  private int eventTypeFromTransitionType(int transitionType) {
-    switch (transitionType) {
-      case Geofence.GEOFENCE_TRANSITION_ENTER:
-        return LocationModule.GEOFENCING_EVENT_ENTER;
-      case Geofence.GEOFENCE_TRANSITION_EXIT:
-        return LocationModule.GEOFENCING_EVENT_EXIT;
-      default:
-        return 0;
-    }
-  }
-
-  private static String getErrorString(int errorCode) {
-    switch (errorCode) {
-      case GeofenceStatusCodes.GEOFENCE_NOT_AVAILABLE:
-        return "Geofencing not available.";
-      case GeofenceStatusCodes.GEOFENCE_TOO_MANY_GEOFENCES:
-        return "Too many geofences.";
-      case GeofenceStatusCodes.GEOFENCE_TOO_MANY_PENDING_INTENTS:
-        return "Too many pending intents.";
-      default:
-        return "Unknown geofencing error.";
-    }
   }
 
   //endregion
diff --git a/node_modules/expo-location/android/src/main/java/expo/modules/location/taskConsumers/LocationTaskConsumer.java b/node_modules/expo-location/android/src/main/java/expo/modules/location/taskConsumers/LocationTaskConsumer.java
index 9f459d0..c3a360f 100644
--- a/node_modules/expo-location/android/src/main/java/expo/modules/location/taskConsumers/LocationTaskConsumer.java
+++ b/node_modules/expo-location/android/src/main/java/expo/modules/location/taskConsumers/LocationTaskConsumer.java
@@ -14,13 +14,6 @@ import android.os.IBinder;
 import android.os.PersistableBundle;
 import android.util.Log;
 
-import com.google.android.gms.location.FusedLocationProviderClient;
-import com.google.android.gms.location.LocationRequest;
-import com.google.android.gms.location.LocationResult;
-import com.google.android.gms.location.LocationServices;
-import com.google.android.gms.tasks.OnCompleteListener;
-import com.google.android.gms.tasks.Task;
-
 import expo.modules.core.MapHelper;
 import expo.modules.core.arguments.MapArguments;
 import expo.modules.core.arguments.ReadableArguments;
@@ -28,11 +21,9 @@ import expo.modules.core.interfaces.Arguments;
 import expo.modules.core.interfaces.LifecycleEventListener;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
-import androidx.annotation.NonNull;
 import expo.modules.location.LocationHelpers;
 import expo.modules.location.services.LocationTaskService;
 import expo.modules.interfaces.taskManager.TaskConsumer;
@@ -44,14 +35,10 @@ import expo.modules.interfaces.taskManager.TaskManagerUtilsInterface;
 public class LocationTaskConsumer extends TaskConsumer implements TaskConsumerInterface, LifecycleEventListener {
   private static final String TAG = "LocationTaskConsumer";
   private static final String FOREGROUND_SERVICE_KEY = "foregroundService";
-  public static int VERSION = 1;
   private static long sLastTimestamp = 0;
 
   private TaskInterface mTask;
-  private PendingIntent mPendingIntent;
   private LocationTaskService mService;
-  private LocationRequest mLocationRequest;
-  private FusedLocationProviderClient mLocationClient;
   private Location mLastReportedLocation;
   private double mDeferredDistance = 0.0;
   private List<Location> mDeferredLocations = new ArrayList<>();
@@ -79,9 +66,6 @@ public class LocationTaskConsumer extends TaskConsumer implements TaskConsumerIn
     stopLocationUpdates();
     stopForegroundService();
     mTask = null;
-    mPendingIntent = null;
-    mLocationRequest = null;
-    mLocationClient = null;
   }
 
   @Override
@@ -98,39 +82,6 @@ public class LocationTaskConsumer extends TaskConsumer implements TaskConsumerIn
 
   @Override
   public void didReceiveBroadcast(Intent intent) {
-    if (mTask == null) {
-      return;
-    }
-
-    LocationResult result = LocationResult.extractResult(intent);
-
-    if (result != null) {
-      List<Location> locations = result.getLocations();
-
-      deferLocations(locations);
-      maybeReportDeferredLocations();
-    } else {
-      try {
-        if(mLocationClient == null){
-          Log.w(TAG, "LocationClient is null.");
-          return;
-        }
-        mLocationClient.getLastLocation().addOnCompleteListener(new OnCompleteListener<Location>() {
-          @Override
-          public void onComplete(@NonNull Task<Location> task) {
-            Location location = task.getResult();
-
-            if (location != null) {
-              Log.i(TAG, "get last location: " + location);
-              deferLocations(Collections.singletonList(location));
-              maybeReportDeferredLocations();
-            }
-          }
-        });
-      } catch (SecurityException e) {
-        Log.e(TAG, "Cannot get last location: " + e.getMessage());
-      }
-    }
   }
 
   @Override
@@ -180,23 +131,9 @@ public class LocationTaskConsumer extends TaskConsumer implements TaskConsumerIn
       Log.w(TAG, "There is no location provider available.");
       return;
     }
-
-    mLocationRequest = LocationHelpers.prepareLocationRequest(mTask.getOptions());
-    mPendingIntent = preparePendingIntent();
-
-    try {
-      mLocationClient = LocationServices.getFusedLocationProviderClient(context);
-      mLocationClient.requestLocationUpdates(mLocationRequest, mPendingIntent);
-    } catch (SecurityException e) {
-      Log.w(TAG, "Location request has been rejected.", e);
-    }
   }
 
   private void stopLocationUpdates() {
-    if (mLocationClient != null && mPendingIntent != null) {
-      mLocationClient.removeLocationUpdates(mPendingIntent);
-      mPendingIntent.cancel();
-    }
   }
 
   private void maybeStartForegroundService() {
@@ -330,10 +267,6 @@ public class LocationTaskConsumer extends TaskConsumer implements TaskConsumerIn
     return newestLocation.getTime() - oldestLocation.getTime() >= interval && mDeferredDistance >= distance;
   }
 
-  private PendingIntent preparePendingIntent() {
-    return getTaskManagerUtils().createTaskIntent(getContext(), mTask);
-  }
-
   private void executeTaskWithLocationBundles(ArrayList<Bundle> locationBundles, TaskExecutionCallback callback) {
     if (locationBundles.size() > 0 && mTask != null) {
       Bundle data = new Bundle();
diff --git a/node_modules/expo-location/babel.config.js b/node_modules/expo-location/babel.config.js
new file mode 100755
index 0000000..68c7d31
--- /dev/null
+++ b/node_modules/expo-location/babel.config.js
@@ -0,0 +1,2 @@
+// @generated by expo-module-scripts
+module.exports = require('expo-module-scripts/babel.config.base');
diff --git a/node_modules/expo-location/build/ExpoLocation.d.ts b/node_modules/expo-location/build/ExpoLocation.d.ts
deleted file mode 100644
index aaa906b..0000000
--- a/node_modules/expo-location/build/ExpoLocation.d.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-declare const _default: import("expo-modules-core").ProxyNativeModule;
-export default _default;
-//# sourceMappingURL=ExpoLocation.d.ts.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/ExpoLocation.d.ts.map b/node_modules/expo-location/build/ExpoLocation.d.ts.map
deleted file mode 100644
index b695f58..0000000
--- a/node_modules/expo-location/build/ExpoLocation.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"ExpoLocation.d.ts","sourceRoot":"","sources":["../src/ExpoLocation.ts"],"names":[],"mappings":";AACA,wBAA+C"}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/ExpoLocation.js b/node_modules/expo-location/build/ExpoLocation.js
deleted file mode 100644
index e7546d9..0000000
--- a/node_modules/expo-location/build/ExpoLocation.js
+++ /dev/null
@@ -1,3 +0,0 @@
-import { NativeModulesProxy } from 'expo-modules-core';
-export default NativeModulesProxy.ExpoLocation;
-//# sourceMappingURL=ExpoLocation.js.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/ExpoLocation.js.map b/node_modules/expo-location/build/ExpoLocation.js.map
deleted file mode 100644
index a3bd0d9..0000000
--- a/node_modules/expo-location/build/ExpoLocation.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"ExpoLocation.js","sourceRoot":"","sources":["../src/ExpoLocation.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAE,MAAM,mBAAmB,CAAC;AACvD,eAAe,kBAAkB,CAAC,YAAY,CAAC","sourcesContent":["import { NativeModulesProxy } from 'expo-modules-core';\nexport default NativeModulesProxy.ExpoLocation;\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/ExpoLocation.web.d.ts b/node_modules/expo-location/build/ExpoLocation.web.d.ts
deleted file mode 100644
index 0e0bde4..0000000
--- a/node_modules/expo-location/build/ExpoLocation.web.d.ts
+++ /dev/null
@@ -1,31 +0,0 @@
-import { PermissionResponse } from 'expo-modules-core';
-import { LocationLastKnownOptions, LocationObject, LocationOptions } from './Location.types';
-/**
- * Gets the permission details. The implementation is not very good as it actually requests
- * for the current location, but there is no better way on web so far :(
- */
-declare function getPermissionsAsync(): Promise<PermissionResponse>;
-declare const _default: {
-    readonly name: string;
-    getProviderStatusAsync(): Promise<{
-        locationServicesEnabled: boolean;
-    }>;
-    getLastKnownPositionAsync(options?: LocationLastKnownOptions): Promise<LocationObject | null>;
-    getCurrentPositionAsync(options: LocationOptions): Promise<LocationObject>;
-    removeWatchAsync(watchId: any): Promise<void>;
-    watchDeviceHeading(headingId: any): Promise<void>;
-    hasServicesEnabledAsync(): Promise<boolean>;
-    geocodeAsync(): Promise<any[]>;
-    reverseGeocodeAsync(): Promise<any[]>;
-    watchPositionImplAsync(watchId: string, options: LocationOptions): Promise<string>;
-    getPermissionsAsync: typeof getPermissionsAsync;
-    requestPermissionsAsync(): Promise<PermissionResponse>;
-    requestForegroundPermissionsAsync(): Promise<PermissionResponse>;
-    requestBackgroundPermissionsAsync(): Promise<PermissionResponse>;
-    getForegroundPermissionsAsync(): Promise<PermissionResponse>;
-    getBackgroundPermissionsAsync(): Promise<PermissionResponse>;
-    startObserving(): void;
-    stopObserving(): void;
-};
-export default _default;
-//# sourceMappingURL=ExpoLocation.web.d.ts.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/ExpoLocation.web.d.ts.map b/node_modules/expo-location/build/ExpoLocation.web.d.ts.map
deleted file mode 100644
index fda6a90..0000000
--- a/node_modules/expo-location/build/ExpoLocation.web.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"ExpoLocation.web.d.ts","sourceRoot":"","sources":["../src/ExpoLocation.web.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAoB,MAAM,mBAAmB,CAAC;AAEzE,OAAO,EACL,wBAAwB,EACxB,cAAc,EACd,eAAe,EAEhB,MAAM,kBAAkB,CAAC;AA2C1B;;;GAGG;AACH,iBAAe,mBAAmB,IAAI,OAAO,CAAC,kBAAkB,CAAC,CAsBhE;;;8BAQiC,QAAQ;QAAE,uBAAuB,EAAE,OAAO,CAAA;KAAE,CAAC;wCAMlE,wBAAwB,GAChC,QAAQ,cAAc,GAAG,IAAI,CAAC;qCAMM,eAAe,GAAG,QAAQ,cAAc,CAAC;oCAa/C,QAAQ,IAAI,CAAC;wCAGT,QAAQ,IAAI,CAAC;+BAGjB,QAAQ,OAAO,CAAC;oBAG3B,QAAQ,GAAG,EAAE,CAAC;2BAGP,QAAQ,GAAG,EAAE,CAAC;oCAGL,MAAM,WAAW,eAAe,GAAG,QAAQ,MAAM,CAAC;;+BAoBvD,QAAQ,kBAAkB,CAAC;yCAGjB,QAAQ,kBAAkB,CAAC;yCAG3B,QAAQ,kBAAkB,CAAC;qCAG/B,QAAQ,kBAAkB,CAAC;qCAG3B,QAAQ,kBAAkB,CAAC;;;;AA7EpE,wBAoFE"}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/ExpoLocation.web.js b/node_modules/expo-location/build/ExpoLocation.web.js
deleted file mode 100644
index 88284f6..0000000
--- a/node_modules/expo-location/build/ExpoLocation.web.js
+++ /dev/null
@@ -1,139 +0,0 @@
-import { PermissionStatus } from 'expo-modules-core';
-import { LocationAccuracy, } from './Location.types';
-import { LocationEventEmitter } from './LocationEventEmitter';
-class GeocoderError extends Error {
-    code;
-    constructor() {
-        super('Geocoder service is not available for this device.');
-        this.code = 'E_NO_GEOCODER';
-    }
-}
-/**
- * Converts `GeolocationPosition` to JavaScript object.
- */
-function geolocationPositionToJSON(position) {
-    const { coords, timestamp } = position;
-    return {
-        coords: {
-            latitude: coords.latitude,
-            longitude: coords.longitude,
-            altitude: coords.altitude,
-            accuracy: coords.accuracy,
-            altitudeAccuracy: coords.altitudeAccuracy,
-            heading: coords.heading,
-            speed: coords.speed,
-        },
-        timestamp,
-    };
-}
-/**
- * Checks whether given location didn't exceed given `maxAge` and fits in the required accuracy.
- */
-function isLocationValid(location, options) {
-    const maxAge = typeof options.maxAge === 'number' ? options.maxAge : Infinity;
-    const requiredAccuracy = typeof options.requiredAccuracy === 'number' ? options.requiredAccuracy : Infinity;
-    const locationAccuracy = location.coords.accuracy ?? Infinity;
-    return Date.now() - location.timestamp <= maxAge && locationAccuracy <= requiredAccuracy;
-}
-/**
- * Gets the permission details. The implementation is not very good as it actually requests
- * for the current location, but there is no better way on web so far :(
- */
-async function getPermissionsAsync() {
-    return new Promise((resolve) => {
-        const resolveWithStatus = (status) => resolve({
-            status,
-            granted: status === PermissionStatus.GRANTED,
-            canAskAgain: true,
-            expires: 0,
-        });
-        navigator.geolocation.getCurrentPosition(() => resolveWithStatus(PermissionStatus.GRANTED), ({ code }) => {
-            if (code === 1 /* PERMISSION_DENIED */) {
-                resolveWithStatus(PermissionStatus.DENIED);
-            }
-            else {
-                resolveWithStatus(PermissionStatus.UNDETERMINED);
-            }
-        }, { enableHighAccuracy: false, maximumAge: Infinity });
-    });
-}
-let lastKnownPosition = null;
-export default {
-    get name() {
-        return 'ExpoLocation';
-    },
-    async getProviderStatusAsync() {
-        return {
-            locationServicesEnabled: 'geolocation' in navigator,
-        };
-    },
-    async getLastKnownPositionAsync(options = {}) {
-        if (lastKnownPosition && isLocationValid(lastKnownPosition, options)) {
-            return lastKnownPosition;
-        }
-        return null;
-    },
-    async getCurrentPositionAsync(options) {
-        return new Promise((resolve, reject) => {
-            const resolver = (position) => {
-                lastKnownPosition = geolocationPositionToJSON(position);
-                resolve(lastKnownPosition);
-            };
-            navigator.geolocation.getCurrentPosition(resolver, reject, {
-                maximumAge: Infinity,
-                enableHighAccuracy: (options.accuracy ?? 0) > LocationAccuracy.Balanced,
-                ...options,
-            });
-        });
-    },
-    async removeWatchAsync(watchId) {
-        navigator.geolocation.clearWatch(watchId);
-    },
-    async watchDeviceHeading(headingId) {
-        console.warn('Location.watchDeviceHeading: is not supported on web');
-    },
-    async hasServicesEnabledAsync() {
-        return 'geolocation' in navigator;
-    },
-    async geocodeAsync() {
-        throw new GeocoderError();
-    },
-    async reverseGeocodeAsync() {
-        throw new GeocoderError();
-    },
-    async watchPositionImplAsync(watchId, options) {
-        return new Promise((resolve) => {
-            // @ts-ignore: the types here need to be fixed
-            watchId = global.navigator.geolocation.watchPosition((position) => {
-                lastKnownPosition = geolocationPositionToJSON(position);
-                LocationEventEmitter.emit('Expo.locationChanged', {
-                    watchId,
-                    location: lastKnownPosition,
-                });
-            }, undefined, 
-            // @ts-ignore: the options object needs to be fixed
-            options);
-            resolve(watchId);
-        });
-    },
-    getPermissionsAsync,
-    async requestPermissionsAsync() {
-        return getPermissionsAsync();
-    },
-    async requestForegroundPermissionsAsync() {
-        return getPermissionsAsync();
-    },
-    async requestBackgroundPermissionsAsync() {
-        return getPermissionsAsync();
-    },
-    async getForegroundPermissionsAsync() {
-        return getPermissionsAsync();
-    },
-    async getBackgroundPermissionsAsync() {
-        return getPermissionsAsync();
-    },
-    // no-op
-    startObserving() { },
-    stopObserving() { },
-};
-//# sourceMappingURL=ExpoLocation.web.js.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/ExpoLocation.web.js.map b/node_modules/expo-location/build/ExpoLocation.web.js.map
deleted file mode 100644
index e14c681..0000000
--- a/node_modules/expo-location/build/ExpoLocation.web.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"ExpoLocation.web.js","sourceRoot":"","sources":["../src/ExpoLocation.web.ts"],"names":[],"mappings":"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","sourcesContent":["import { PermissionResponse, PermissionStatus } from 'expo-modules-core';\n\nimport {\n  LocationLastKnownOptions,\n  LocationObject,\n  LocationOptions,\n  LocationAccuracy,\n} from './Location.types';\nimport { LocationEventEmitter } from './LocationEventEmitter';\n\nclass GeocoderError extends Error {\n  code: string;\n\n  constructor() {\n    super('Geocoder service is not available for this device.');\n    this.code = 'E_NO_GEOCODER';\n  }\n}\n\n/**\n * Converts `GeolocationPosition` to JavaScript object.\n */\nfunction geolocationPositionToJSON(position: LocationObject): LocationObject {\n  const { coords, timestamp } = position;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed,\n    },\n    timestamp,\n  };\n}\n\n/**\n * Checks whether given location didn't exceed given `maxAge` and fits in the required accuracy.\n */\nfunction isLocationValid(location: LocationObject, options: LocationLastKnownOptions): boolean {\n  const maxAge = typeof options.maxAge === 'number' ? options.maxAge : Infinity;\n  const requiredAccuracy =\n    typeof options.requiredAccuracy === 'number' ? options.requiredAccuracy : Infinity;\n  const locationAccuracy = location.coords.accuracy ?? Infinity;\n\n  return Date.now() - location.timestamp <= maxAge && locationAccuracy <= requiredAccuracy;\n}\n\n/**\n * Gets the permission details. The implementation is not very good as it actually requests\n * for the current location, but there is no better way on web so far :(\n */\nasync function getPermissionsAsync(): Promise<PermissionResponse> {\n  return new Promise<PermissionResponse>((resolve) => {\n    const resolveWithStatus = (status) =>\n      resolve({\n        status,\n        granted: status === PermissionStatus.GRANTED,\n        canAskAgain: true,\n        expires: 0,\n      });\n\n    navigator.geolocation.getCurrentPosition(\n      () => resolveWithStatus(PermissionStatus.GRANTED),\n      ({ code }) => {\n        if (code === 1 /* PERMISSION_DENIED */) {\n          resolveWithStatus(PermissionStatus.DENIED);\n        } else {\n          resolveWithStatus(PermissionStatus.UNDETERMINED);\n        }\n      },\n      { enableHighAccuracy: false, maximumAge: Infinity }\n    );\n  });\n}\n\nlet lastKnownPosition: LocationObject | null = null;\n\nexport default {\n  get name(): string {\n    return 'ExpoLocation';\n  },\n  async getProviderStatusAsync(): Promise<{ locationServicesEnabled: boolean }> {\n    return {\n      locationServicesEnabled: 'geolocation' in navigator,\n    };\n  },\n  async getLastKnownPositionAsync(\n    options: LocationLastKnownOptions = {}\n  ): Promise<LocationObject | null> {\n    if (lastKnownPosition && isLocationValid(lastKnownPosition, options)) {\n      return lastKnownPosition;\n    }\n    return null;\n  },\n  async getCurrentPositionAsync(options: LocationOptions): Promise<LocationObject> {\n    return new Promise<LocationObject>((resolve, reject) => {\n      const resolver = (position) => {\n        lastKnownPosition = geolocationPositionToJSON(position);\n        resolve(lastKnownPosition);\n      };\n      navigator.geolocation.getCurrentPosition(resolver, reject, {\n        maximumAge: Infinity,\n        enableHighAccuracy: (options.accuracy ?? 0) > LocationAccuracy.Balanced,\n        ...options,\n      });\n    });\n  },\n  async removeWatchAsync(watchId): Promise<void> {\n    navigator.geolocation.clearWatch(watchId);\n  },\n  async watchDeviceHeading(headingId): Promise<void> {\n    console.warn('Location.watchDeviceHeading: is not supported on web');\n  },\n  async hasServicesEnabledAsync(): Promise<boolean> {\n    return 'geolocation' in navigator;\n  },\n  async geocodeAsync(): Promise<any[]> {\n    throw new GeocoderError();\n  },\n  async reverseGeocodeAsync(): Promise<any[]> {\n    throw new GeocoderError();\n  },\n  async watchPositionImplAsync(watchId: string, options: LocationOptions): Promise<string> {\n    return new Promise<string>((resolve) => {\n      // @ts-ignore: the types here need to be fixed\n      watchId = global.navigator.geolocation.watchPosition(\n        (position) => {\n          lastKnownPosition = geolocationPositionToJSON(position);\n          LocationEventEmitter.emit('Expo.locationChanged', {\n            watchId,\n            location: lastKnownPosition,\n          });\n        },\n        undefined,\n        // @ts-ignore: the options object needs to be fixed\n        options\n      );\n      resolve(watchId);\n    });\n  },\n\n  getPermissionsAsync,\n  async requestPermissionsAsync(): Promise<PermissionResponse> {\n    return getPermissionsAsync();\n  },\n  async requestForegroundPermissionsAsync(): Promise<PermissionResponse> {\n    return getPermissionsAsync();\n  },\n  async requestBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n    return getPermissionsAsync();\n  },\n  async getForegroundPermissionsAsync(): Promise<PermissionResponse> {\n    return getPermissionsAsync();\n  },\n  async getBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n    return getPermissionsAsync();\n  },\n\n  // no-op\n  startObserving() {},\n  stopObserving() {},\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/GeolocationPolyfill.d.ts b/node_modules/expo-location/build/GeolocationPolyfill.d.ts
deleted file mode 100644
index 30dfebd..0000000
--- a/node_modules/expo-location/build/GeolocationPolyfill.d.ts
+++ /dev/null
@@ -1,5 +0,0 @@
-/**
- * Polyfills `navigator.geolocation` for interop with the core React Native and Web API approach to geolocation.
- */
-export declare function installWebGeolocationPolyfill(): void;
-//# sourceMappingURL=GeolocationPolyfill.d.ts.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/GeolocationPolyfill.d.ts.map b/node_modules/expo-location/build/GeolocationPolyfill.d.ts.map
deleted file mode 100644
index 112a224..0000000
--- a/node_modules/expo-location/build/GeolocationPolyfill.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"GeolocationPolyfill.d.ts","sourceRoot":"","sources":["../src/GeolocationPolyfill.ts"],"names":[],"mappings":"AAgBA;;GAEG;AACH,wBAAgB,6BAA6B,IAAI,IAAI,CAqBpD"}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/GeolocationPolyfill.js b/node_modules/expo-location/build/GeolocationPolyfill.js
deleted file mode 100644
index dce38b4..0000000
--- a/node_modules/expo-location/build/GeolocationPolyfill.js
+++ /dev/null
@@ -1,62 +0,0 @@
-import { Platform } from 'expo-modules-core';
-import ExpoLocation from './ExpoLocation';
-import { LocationAccuracy } from './Location.types';
-import { LocationSubscriber } from './LocationSubscribers';
-// @needsAudit
-/**
- * Polyfills `navigator.geolocation` for interop with the core React Native and Web API approach to geolocation.
- */
-export function installWebGeolocationPolyfill() {
-    if (Platform.OS !== 'web') {
-        // Make sure `window.navigator` is defined in the global scope.
-        if (!('window' in global)) {
-            global.window = global;
-        }
-        if (!('navigator' in global.window)) {
-            global.window.navigator = {};
-        }
-        // @ts-ignore
-        window.navigator.geolocation = {
-            getCurrentPosition,
-            watchPosition,
-            clearWatch,
-            // We don't polyfill stopObserving, this is an internal method that probably should not even exist
-            // in react-native docs
-            stopObserving: () => { },
-        };
-    }
-}
-function convertGeolocationOptions(options) {
-    return {
-        accuracy: options.enableHighAccuracy ? LocationAccuracy.High : LocationAccuracy.Balanced,
-    };
-}
-function getCurrentPosition(success, error = () => { }, options = {}) {
-    _getCurrentPositionAsyncWrapper(success, error, options);
-}
-// This function exists to let us continue to return undefined from getCurrentPosition, while still
-// using async/await for the internal implementation of it
-async function _getCurrentPositionAsyncWrapper(success, error, options) {
-    try {
-        await ExpoLocation.requestPermissionsAsync();
-        const result = await ExpoLocation.getCurrentPositionAsync(convertGeolocationOptions(options));
-        success(result);
-    }
-    catch (e) {
-        error(e);
-    }
-}
-// Polyfill: navigator.geolocation.watchPosition
-function watchPosition(success, error, options) {
-    const watchId = LocationSubscriber.registerCallback(success);
-    ExpoLocation.watchPositionImplAsync(watchId, options).catch((err) => {
-        LocationSubscriber.unregisterCallback(watchId);
-        error({ watchId, message: err.message, code: err.code });
-    });
-    return watchId;
-}
-// Polyfill: navigator.geolocation.clearWatch
-function clearWatch(watchId) {
-    LocationSubscriber.unregisterCallback(watchId);
-}
-//# sourceMappingURL=GeolocationPolyfill.js.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/GeolocationPolyfill.js.map b/node_modules/expo-location/build/GeolocationPolyfill.js.map
deleted file mode 100644
index 0af25ca..0000000
--- a/node_modules/expo-location/build/GeolocationPolyfill.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"GeolocationPolyfill.js","sourceRoot":"","sources":["../src/GeolocationPolyfill.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,mBAAmB,CAAC;AAE7C,OAAO,YAAY,MAAM,gBAAgB,CAAC;AAC1C,OAAO,EAAkB,gBAAgB,EAAmB,MAAM,kBAAkB,CAAC;AACrF,OAAO,EAAE,kBAAkB,EAAE,MAAM,uBAAuB,CAAC;AAW3D,cAAc;AACd;;GAEG;AACH,MAAM,UAAU,6BAA6B;IAC3C,IAAI,QAAQ,CAAC,EAAE,KAAK,KAAK,EAAE;QACzB,+DAA+D;QAC/D,IAAI,CAAC,CAAC,QAAQ,IAAI,MAAM,CAAC,EAAE;YACzB,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC;SACxB;QACD,IAAI,CAAC,CAAC,WAAW,IAAI,MAAM,CAAC,MAAM,CAAC,EAAE;YACnC,MAAM,CAAC,MAAM,CAAC,SAAS,GAAG,EAAE,CAAC;SAC9B;QAED,aAAa;QACb,MAAM,CAAC,SAAS,CAAC,WAAW,GAAG;YAC7B,kBAAkB;YAClB,aAAa;YACb,UAAU;YAEV,kGAAkG;YAClG,uBAAuB;YACvB,aAAa,EAAE,GAAG,EAAE,GAAE,CAAC;SACxB,CAAC;KACH;AACH,CAAC;AAED,SAAS,yBAAyB,CAAC,OAA2B;IAC5D,OAAO;QACL,QAAQ,EAAE,OAAO,CAAC,kBAAkB,CAAC,CAAC,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,gBAAgB,CAAC,QAAQ;KACzF,CAAC;AACJ,CAAC;AAED,SAAS,kBAAkB,CACzB,OAAmC,EACnC,QAAkC,GAAG,EAAE,GAAE,CAAC,EAC1C,UAA8B,EAAE;IAEhC,+BAA+B,CAAC,OAAO,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;AAC3D,CAAC;AAED,mGAAmG;AACnG,0DAA0D;AAC1D,KAAK,UAAU,+BAA+B,CAC5C,OAAmC,EACnC,KAA+B,EAC/B,OAA2B;IAE3B,IAAI;QACF,MAAM,YAAY,CAAC,uBAAuB,EAAE,CAAC;QAC7C,MAAM,MAAM,GAAG,MAAM,YAAY,CAAC,uBAAuB,CAAC,yBAAyB,CAAC,OAAO,CAAC,CAAC,CAAC;QAC9F,OAAO,CAAC,MAAM,CAAC,CAAC;KACjB;IAAC,OAAO,CAAC,EAAE;QACV,KAAK,CAAC,CAAC,CAAC,CAAC;KACV;AACH,CAAC;AAED,gDAAgD;AAChD,SAAS,aAAa,CACpB,OAAmC,EACnC,KAA+B,EAC/B,OAA2B;IAE3B,MAAM,OAAO,GAAG,kBAAkB,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;IAE7D,YAAY,CAAC,sBAAsB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;QAClE,kBAAkB,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;QAC/C,KAAK,CAAC,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,CAAC,OAAO,EAAE,IAAI,EAAE,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;IAC3D,CAAC,CAAC,CAAC;IAEH,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,6CAA6C;AAC7C,SAAS,UAAU,CAAC,OAAe;IACjC,kBAAkB,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;AACjD,CAAC","sourcesContent":["import { Platform } from 'expo-modules-core';\n\nimport ExpoLocation from './ExpoLocation';\nimport { LocationObject, LocationAccuracy, LocationOptions } from './Location.types';\nimport { LocationSubscriber } from './LocationSubscribers';\n\ntype GeolocationSuccessCallback = (data: LocationObject) => void;\ntype GeolocationErrorCallback = (error: any) => void;\n\ntype GeolocationOptions = {\n  enableHighAccuracy?: boolean;\n};\n\ndeclare const global: any;\n\n// @needsAudit\n/**\n * Polyfills `navigator.geolocation` for interop with the core React Native and Web API approach to geolocation.\n */\nexport function installWebGeolocationPolyfill(): void {\n  if (Platform.OS !== 'web') {\n    // Make sure `window.navigator` is defined in the global scope.\n    if (!('window' in global)) {\n      global.window = global;\n    }\n    if (!('navigator' in global.window)) {\n      global.window.navigator = {};\n    }\n\n    // @ts-ignore\n    window.navigator.geolocation = {\n      getCurrentPosition,\n      watchPosition,\n      clearWatch,\n\n      // We don't polyfill stopObserving, this is an internal method that probably should not even exist\n      // in react-native docs\n      stopObserving: () => {},\n    };\n  }\n}\n\nfunction convertGeolocationOptions(options: GeolocationOptions): LocationOptions {\n  return {\n    accuracy: options.enableHighAccuracy ? LocationAccuracy.High : LocationAccuracy.Balanced,\n  };\n}\n\nfunction getCurrentPosition(\n  success: GeolocationSuccessCallback,\n  error: GeolocationErrorCallback = () => {},\n  options: GeolocationOptions = {}\n): void {\n  _getCurrentPositionAsyncWrapper(success, error, options);\n}\n\n// This function exists to let us continue to return undefined from getCurrentPosition, while still\n// using async/await for the internal implementation of it\nasync function _getCurrentPositionAsyncWrapper(\n  success: GeolocationSuccessCallback,\n  error: GeolocationErrorCallback,\n  options: GeolocationOptions\n): Promise<any> {\n  try {\n    await ExpoLocation.requestPermissionsAsync();\n    const result = await ExpoLocation.getCurrentPositionAsync(convertGeolocationOptions(options));\n    success(result);\n  } catch (e) {\n    error(e);\n  }\n}\n\n// Polyfill: navigator.geolocation.watchPosition\nfunction watchPosition(\n  success: GeolocationSuccessCallback,\n  error: GeolocationErrorCallback,\n  options: GeolocationOptions\n) {\n  const watchId = LocationSubscriber.registerCallback(success);\n\n  ExpoLocation.watchPositionImplAsync(watchId, options).catch((err) => {\n    LocationSubscriber.unregisterCallback(watchId);\n    error({ watchId, message: err.message, code: err.code });\n  });\n\n  return watchId;\n}\n\n// Polyfill: navigator.geolocation.clearWatch\nfunction clearWatch(watchId: number) {\n  LocationSubscriber.unregisterCallback(watchId);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/Location.d.ts b/node_modules/expo-location/build/Location.d.ts
deleted file mode 100644
index a3d3415..0000000
--- a/node_modules/expo-location/build/Location.d.ts
+++ /dev/null
@@ -1,256 +0,0 @@
-import { PermissionStatus, PermissionResponse, PermissionHookOptions } from 'expo-modules-core';
-import { LocationAccuracy, LocationCallback, LocationGeocodedAddress, LocationGeocodedLocation, LocationHeadingCallback, LocationHeadingObject, LocationLastKnownOptions, LocationObject, LocationOptions, LocationPermissionResponse, LocationProviderStatus, LocationRegion, LocationSubscription, LocationTaskOptions, LocationActivityType, LocationGeofencingEventType, LocationGeofencingRegionState, LocationGeocodingOptions } from './Location.types';
-import { LocationEventEmitter } from './LocationEventEmitter';
-import { _getCurrentWatchId } from './LocationSubscribers';
-/**
- * @deprecated The Geocoding web api is no longer available from SDK 49 onwards. Use [Place Autocomplete](https://developers.google.com/maps/documentation/places/web-service/autocomplete) instead.
- * @param apiKey Google API key obtained from Google API Console. This API key must have `Geocoding API`
- * enabled, otherwise your geocoding requests will be denied.
- */
-declare function setGoogleApiKey(_apiKey: string): void;
-/**
- * Check status of location providers.
- * @return A promise which fulfills with an object of type [LocationProviderStatus](#locationproviderstatus).
- */
-export declare function getProviderStatusAsync(): Promise<LocationProviderStatus>;
-/**
- * Asks the user to turn on high accuracy location mode which enables network provider that uses
- * Google Play services to improve location accuracy and location-based services.
- * @return A promise resolving as soon as the user accepts the dialog. Rejects if denied.
- */
-export declare function enableNetworkProviderAsync(): Promise<void>;
-/**
- * Requests for one-time delivery of the user's current location.
- * Depending on given `accuracy` option it may take some time to resolve,
- * especially when you're inside a building.
- * > __Note:__ Calling it causes the location manager to obtain a location fix which may take several
- * > seconds. Consider using [`Location.getLastKnownPositionAsync`](#locationgetlastknownpositionasyncoptions)
- * > if you expect to get a quick response and high accuracy is not required.
- * @param options
- * @return A promise which fulfills with an object of type [`LocationObject`](#locationobject).
- */
-export declare function getCurrentPositionAsync(options?: LocationOptions): Promise<LocationObject>;
-/**
- * Gets the last known position of the device or `null` if it's not available or doesn't match given
- * requirements such as maximum age or required accuracy.
- * It's considered to be faster than `getCurrentPositionAsync` as it doesn't request for the current
- * location, but keep in mind the returned location may not be up-to-date.
- * @param options
- * @return A promise which fulfills with an object of type [LocationObject](#locationobject) or
- * `null` if it's not available or doesn't match given requirements such as maximum age or required
- * accuracy.
- */
-export declare function getLastKnownPositionAsync(options?: LocationLastKnownOptions): Promise<LocationObject | null>;
-/**
- * Subscribe to location updates from the device. Please note that updates will only occur while the
- * application is in the foreground. To get location updates while in background you'll need to use
- * [Location.startLocationUpdatesAsync](#locationstartlocationupdatesasynctaskname-options).
- * @param options
- * @param callback This function is called on each location update. It receives an object of type
- * [`LocationObject`](#locationobject) as the first argument.
- * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.
- */
-export declare function watchPositionAsync(options: LocationOptions, callback: LocationCallback): Promise<LocationSubscription>;
-/**
- * Gets the current heading information from the device. To simplify, it calls `watchHeadingAsync`
- * and waits for a couple of updates, and then returns the one that is accurate enough.
- * @return A promise which fulfills with an object of type [LocationHeadingObject](#locationheadingobject).
- */
-export declare function getHeadingAsync(): Promise<LocationHeadingObject>;
-/**
- * Subscribe to compass updates from the device.
- * @param callback This function is called on each compass update. It receives an object of type
- * [LocationHeadingObject](#locationheadingobject) as the first argument.
- * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.
- */
-export declare function watchHeadingAsync(callback: LocationHeadingCallback): Promise<LocationSubscription>;
-/**
- * Geocode an address string to latitude-longitude location.
- * > **Note**: Using the Geocoding web api is no longer supported. Use [Place Autocomplete](https://developers.google.com/maps/documentation/places/web-service/autocomplete) instead.
- *
- * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many
- * > requests at a time can result in an error, so they have to be managed properly.
- * > It's also discouraged to use geocoding while the app is in the background and its results won't
- * > be shown to the user immediately.
- *
- * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user
- * > before geocoding can be used.
- * @param address A string representing address, eg. `"Baker Street London"`.
- * @param options
- * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedLocation`](#locationgeocodedlocation) objects.
- */
-export declare function geocodeAsync(address: string, options?: LocationGeocodingOptions): Promise<LocationGeocodedLocation[]>;
-/**
- * Reverse geocode a location to postal address.
- * > **Note**: Using the Geocoding web api is no longer supported. Use [Place Autocomplete](https://developers.google.com/maps/documentation/places/web-service/autocomplete) instead.
- *
- * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many
- * > requests at a time can result in an error, so they have to be managed properly.
- * > It's also discouraged to use geocoding while the app is in the background and its results won't
- * > be shown to the user immediately.
- *
- * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user
- * > before geocoding can be used.
- * @param location An object representing a location.
- * @param options
- * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedAddress`](#locationgeocodedaddress) objects.
- */
-export declare function reverseGeocodeAsync(location: Pick<LocationGeocodedLocation, 'latitude' | 'longitude'>, options?: LocationGeocodingOptions): Promise<LocationGeocodedAddress[]>;
-/**
- * Checks user's permissions for accessing location.
- * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).
- * @deprecated Use [`getForegroundPermissionsAsync`](#locationgetforegroundpermissionsasync) or [`getBackgroundPermissionsAsync`](#locationgetbackgroundpermissionsasync) instead.
- */
-export declare function getPermissionsAsync(): Promise<LocationPermissionResponse>;
-/**
- * Asks the user to grant permissions for location.
- * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).
- * @deprecated Use [`requestForegroundPermissionsAsync`](#locationrequestforegroundpermissionsasync) or [`requestBackgroundPermissionsAsync`](#locationrequestbackgroundpermissionsasync) instead.
- */
-export declare function requestPermissionsAsync(): Promise<LocationPermissionResponse>;
-/**
- * Checks user's permissions for accessing location while the app is in the foreground.
- * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).
- */
-export declare function getForegroundPermissionsAsync(): Promise<LocationPermissionResponse>;
-/**
- * Asks the user to grant permissions for location while the app is in the foreground.
- * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).
- */
-export declare function requestForegroundPermissionsAsync(): Promise<LocationPermissionResponse>;
-/**
- * Check or request permissions for the foreground location.
- * This uses both `requestForegroundPermissionsAsync` and `getForegroundPermissionsAsync` to interact with the permissions.
- *
- * @example
- * ```ts
- * const [status, requestPermission] = Location.useForegroundPermissions();
- * ```
- */
-export declare const useForegroundPermissions: (options?: PermissionHookOptions<object> | undefined) => [LocationPermissionResponse | null, () => Promise<LocationPermissionResponse>, () => Promise<LocationPermissionResponse>];
-/**
- * Checks user's permissions for accessing location while the app is in the background.
- * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).
- */
-export declare function getBackgroundPermissionsAsync(): Promise<PermissionResponse>;
-/**
- * Asks the user to grant permissions for location while the app is in the background.
- * On __Android 11 or higher__: this method will open the system settings page - before that happens
- * you should explain to the user why your application needs background location permission.
- * For example, you can use `Modal` component from `react-native` to do that.
- * > __Note__: Foreground permissions should be granted before asking for the background permissions
- * (your app can't obtain background permission without foreground permission).
- * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).
- */
-export declare function requestBackgroundPermissionsAsync(): Promise<PermissionResponse>;
-/**
- * Check or request permissions for the background location.
- * This uses both `requestBackgroundPermissionsAsync` and `getBackgroundPermissionsAsync` to
- * interact with the permissions.
- *
- * @example
- * ```ts
- * const [status, requestPermission] = Location.useBackgroundPermissions();
- * ```
- */
-export declare const useBackgroundPermissions: (options?: PermissionHookOptions<object> | undefined) => [PermissionResponse | null, () => Promise<PermissionResponse>, () => Promise<PermissionResponse>];
-/**
- * Checks whether location services are enabled by the user.
- * @return A promise which fulfills to `true` if location services are enabled on the device,
- * or `false` if not.
- */
-export declare function hasServicesEnabledAsync(): Promise<boolean>;
-export declare function isBackgroundLocationAvailableAsync(): Promise<boolean>;
-/**
- * Registers for receiving location updates that can also come when the app is in the background.
- *
- * # Task parameters
- *
- * Background location task will be receiving following data:
- * - `locations` - An array of the new locations.
- *
- * ```ts
- * import * as TaskManager from 'expo-task-manager';
- *
- * TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { locations }, error }) => {
- *  if (error) {
- *    // check `error.message` for more details.
- *    return;
- *  }
- *  console.log('Received new locations', locations);
- * });
- * ```
- *
- * @param taskName Name of the task receiving location updates.
- * @param options An object of options passed to the location manager.
- *
- * @return A promise resolving once the task with location updates is registered.
- */
-export declare function startLocationUpdatesAsync(taskName: string, options?: LocationTaskOptions): Promise<void>;
-/**
- * Stops geofencing for specified task.
- * @param taskName Name of the background location task to stop.
- * @return A promise resolving as soon as the task is unregistered.
- */
-export declare function stopLocationUpdatesAsync(taskName: string): Promise<void>;
-/**
- * @param taskName Name of the location task to check.
- * @return A promise which fulfills with boolean value indicating whether the location task is
- * started or not.
- */
-export declare function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean>;
-/**
- * Starts geofencing for given regions. When the new event comes, the task with specified name will
- * be called with the region that the device enter to or exit from.
- * If you want to add or remove regions from already running geofencing task, you can just call
- * `startGeofencingAsync` again with the new array of regions.
- *
- * # Task parameters
- *
- * Geofencing task will be receiving following data:
- *  - `eventType` - Indicates the reason for calling the task, which can be triggered by entering or exiting the region.
- *    See [GeofencingEventType](#geofencingeventtype).
- *  - `region` - Object containing details about updated region. See [LocationRegion](#locationregion) for more details.
- *
- * @param taskName Name of the task that will be called when the device enters or exits from specified regions.
- * @param regions Array of region objects to be geofenced.
- *
- * @return A promise resolving as soon as the task is registered.
- *
- * @example
- * ```ts
- * import { GeofencingEventType } from 'expo-location';
- * import * as TaskManager from 'expo-task-manager';
- *
- *  TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { eventType, region }, error }) => {
- *   if (error) {
- *     // check `error.message` for more details.
- *     return;
- *   }
- *   if (eventType === GeofencingEventType.Enter) {
- *     console.log("You've entered region:", region);
- *   } else if (eventType === GeofencingEventType.Exit) {
- *     console.log("You've left region:", region);
- *   }
- * });
- * ```
- */
-export declare function startGeofencingAsync(taskName: string, regions?: LocationRegion[]): Promise<void>;
-/**
- * Stops geofencing for specified task. It unregisters the background task so the app will not be
- * receiving any updates, especially in the background.
- * @param taskName Name of the task to unregister.
- * @return A promise resolving as soon as the task is unregistered.
- */
-export declare function stopGeofencingAsync(taskName: string): Promise<void>;
-/**
- * @param taskName Name of the geofencing task to check.
- * @return A promise which fulfills with boolean value indicating whether the geofencing task is
- * started or not.
- */
-export declare function hasStartedGeofencingAsync(taskName: string): Promise<boolean>;
-export { LocationEventEmitter as EventEmitter, _getCurrentWatchId };
-export { LocationAccuracy as Accuracy, LocationActivityType as ActivityType, LocationGeofencingEventType as GeofencingEventType, LocationGeofencingRegionState as GeofencingRegionState, PermissionStatus, PermissionHookOptions, setGoogleApiKey, };
-export { installWebGeolocationPolyfill } from './GeolocationPolyfill';
-export * from './Location.types';
-//# sourceMappingURL=Location.d.ts.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/Location.d.ts.map b/node_modules/expo-location/build/Location.d.ts.map
deleted file mode 100644
index d1cfd95..0000000
--- a/node_modules/expo-location/build/Location.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Location.d.ts","sourceRoot":"","sources":["../src/Location.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/Location.js b/node_modules/expo-location/build/Location.js
deleted file mode 100644
index c11d4ce..0000000
--- a/node_modules/expo-location/build/Location.js
+++ /dev/null
@@ -1,418 +0,0 @@
-import { PermissionStatus, createPermissionHook, Platform, } from 'expo-modules-core';
-import ExpoLocation from './ExpoLocation';
-import { LocationAccuracy, LocationActivityType, LocationGeofencingEventType, LocationGeofencingRegionState, } from './Location.types';
-import { LocationEventEmitter } from './LocationEventEmitter';
-import { LocationSubscriber, HeadingSubscriber, _getCurrentWatchId } from './LocationSubscribers';
-// @needsAudit
-/**
- * @deprecated The Geocoding web api is no longer available from SDK 49 onwards. Use [Place Autocomplete](https://developers.google.com/maps/documentation/places/web-service/autocomplete) instead.
- * @param apiKey Google API key obtained from Google API Console. This API key must have `Geocoding API`
- * enabled, otherwise your geocoding requests will be denied.
- */
-function setGoogleApiKey(_apiKey) { }
-// @needsAudit
-/**
- * Check status of location providers.
- * @return A promise which fulfills with an object of type [LocationProviderStatus](#locationproviderstatus).
- */
-export async function getProviderStatusAsync() {
-    return ExpoLocation.getProviderStatusAsync();
-}
-// @needsAudit
-/**
- * Asks the user to turn on high accuracy location mode which enables network provider that uses
- * Google Play services to improve location accuracy and location-based services.
- * @return A promise resolving as soon as the user accepts the dialog. Rejects if denied.
- */
-export async function enableNetworkProviderAsync() {
-    // If network provider is disabled (user's location mode is set to "Device only"),
-    // Android's location provider may not give you any results. Use this method in order to ask the user
-    // to change the location mode to "High accuracy" which uses Google Play services and enables network provider.
-    // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.
-    if (Platform.OS === 'android') {
-        return ExpoLocation.enableNetworkProviderAsync();
-    }
-}
-// @needsAudit
-/**
- * Requests for one-time delivery of the user's current location.
- * Depending on given `accuracy` option it may take some time to resolve,
- * especially when you're inside a building.
- * > __Note:__ Calling it causes the location manager to obtain a location fix which may take several
- * > seconds. Consider using [`Location.getLastKnownPositionAsync`](#locationgetlastknownpositionasyncoptions)
- * > if you expect to get a quick response and high accuracy is not required.
- * @param options
- * @return A promise which fulfills with an object of type [`LocationObject`](#locationobject).
- */
-export async function getCurrentPositionAsync(options = {}) {
-    return ExpoLocation.getCurrentPositionAsync(options);
-}
-// @needsAudit
-/**
- * Gets the last known position of the device or `null` if it's not available or doesn't match given
- * requirements such as maximum age or required accuracy.
- * It's considered to be faster than `getCurrentPositionAsync` as it doesn't request for the current
- * location, but keep in mind the returned location may not be up-to-date.
- * @param options
- * @return A promise which fulfills with an object of type [LocationObject](#locationobject) or
- * `null` if it's not available or doesn't match given requirements such as maximum age or required
- * accuracy.
- */
-export async function getLastKnownPositionAsync(options = {}) {
-    return ExpoLocation.getLastKnownPositionAsync(options);
-}
-// @needsAudit
-/**
- * Subscribe to location updates from the device. Please note that updates will only occur while the
- * application is in the foreground. To get location updates while in background you'll need to use
- * [Location.startLocationUpdatesAsync](#locationstartlocationupdatesasynctaskname-options).
- * @param options
- * @param callback This function is called on each location update. It receives an object of type
- * [`LocationObject`](#locationobject) as the first argument.
- * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.
- */
-export async function watchPositionAsync(options, callback) {
-    const watchId = LocationSubscriber.registerCallback(callback);
-    await ExpoLocation.watchPositionImplAsync(watchId, options);
-    return {
-        remove() {
-            LocationSubscriber.unregisterCallback(watchId);
-        },
-    };
-}
-// @needsAudit
-/**
- * Gets the current heading information from the device. To simplify, it calls `watchHeadingAsync`
- * and waits for a couple of updates, and then returns the one that is accurate enough.
- * @return A promise which fulfills with an object of type [LocationHeadingObject](#locationheadingobject).
- */
-export async function getHeadingAsync() {
-    return new Promise(async (resolve) => {
-        let tries = 0;
-        const subscription = await watchHeadingAsync((heading) => {
-            if (heading.accuracy > 1 || tries > 5) {
-                subscription.remove();
-                resolve(heading);
-            }
-            else {
-                tries += 1;
-            }
-        });
-    });
-}
-// @needsAudit
-/**
- * Subscribe to compass updates from the device.
- * @param callback This function is called on each compass update. It receives an object of type
- * [LocationHeadingObject](#locationheadingobject) as the first argument.
- * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.
- */
-export async function watchHeadingAsync(callback) {
-    const watchId = HeadingSubscriber.registerCallback(callback);
-    await ExpoLocation.watchDeviceHeading(watchId);
-    return {
-        remove() {
-            HeadingSubscriber.unregisterCallback(watchId);
-        },
-    };
-}
-// @needsAudit
-/**
- * Geocode an address string to latitude-longitude location.
- * > **Note**: Using the Geocoding web api is no longer supported. Use [Place Autocomplete](https://developers.google.com/maps/documentation/places/web-service/autocomplete) instead.
- *
- * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many
- * > requests at a time can result in an error, so they have to be managed properly.
- * > It's also discouraged to use geocoding while the app is in the background and its results won't
- * > be shown to the user immediately.
- *
- * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user
- * > before geocoding can be used.
- * @param address A string representing address, eg. `"Baker Street London"`.
- * @param options
- * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedLocation`](#locationgeocodedlocation) objects.
- */
-export async function geocodeAsync(address, options) {
-    if (typeof address !== 'string') {
-        throw new TypeError(`Address to geocode must be a string. Got ${address} instead.`);
-    }
-    if (options?.useGoogleMaps || Platform.OS === 'web') {
-        if (__DEV__) {
-            console.warn('The Geocoding API has been removed in SDK 49, use Place Autocomplete service instead' +
-                '(https://developers.google.com/maps/documentation/places/web-service/autocomplete)');
-        }
-        return [];
-    }
-    return await ExpoLocation.geocodeAsync(address);
-}
-// @needsAudit
-/**
- * Reverse geocode a location to postal address.
- * > **Note**: Using the Geocoding web api is no longer supported. Use [Place Autocomplete](https://developers.google.com/maps/documentation/places/web-service/autocomplete) instead.
- *
- * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many
- * > requests at a time can result in an error, so they have to be managed properly.
- * > It's also discouraged to use geocoding while the app is in the background and its results won't
- * > be shown to the user immediately.
- *
- * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user
- * > before geocoding can be used.
- * @param location An object representing a location.
- * @param options
- * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedAddress`](#locationgeocodedaddress) objects.
- */
-export async function reverseGeocodeAsync(location, options) {
-    if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {
-        throw new TypeError('Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.');
-    }
-    if (options?.useGoogleMaps || Platform.OS === 'web') {
-        if (__DEV__) {
-            console.warn('The Geocoding API has been removed in SDK 49, use Place Autocomplete service instead' +
-                '(https://developers.google.com/maps/documentation/places/web-service/autocomplete)');
-        }
-        return [];
-    }
-    return await ExpoLocation.reverseGeocodeAsync(location);
-}
-// @needsAudit
-/**
- * Checks user's permissions for accessing location.
- * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).
- * @deprecated Use [`getForegroundPermissionsAsync`](#locationgetforegroundpermissionsasync) or [`getBackgroundPermissionsAsync`](#locationgetbackgroundpermissionsasync) instead.
- */
-export async function getPermissionsAsync() {
-    console.warn(`"getPermissionsAsync()" is now deprecated. Please use "getForegroundPermissionsAsync()" or "getBackgroundPermissionsAsync()" instead.`);
-    return await ExpoLocation.getPermissionsAsync();
-}
-// @needsAudit
-/**
- * Asks the user to grant permissions for location.
- * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).
- * @deprecated Use [`requestForegroundPermissionsAsync`](#locationrequestforegroundpermissionsasync) or [`requestBackgroundPermissionsAsync`](#locationrequestbackgroundpermissionsasync) instead.
- */
-export async function requestPermissionsAsync() {
-    console.warn(`"requestPermissionsAsync()" is now deprecated. Please use "requestForegroundPermissionsAsync()" or "requestBackgroundPermissionsAsync()" instead.`);
-    return await ExpoLocation.requestPermissionsAsync();
-}
-// @needsAudit
-/**
- * Checks user's permissions for accessing location while the app is in the foreground.
- * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).
- */
-export async function getForegroundPermissionsAsync() {
-    return await ExpoLocation.getForegroundPermissionsAsync();
-}
-// @needsAudit
-/**
- * Asks the user to grant permissions for location while the app is in the foreground.
- * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).
- */
-export async function requestForegroundPermissionsAsync() {
-    return await ExpoLocation.requestForegroundPermissionsAsync();
-}
-// @needsAudit
-/**
- * Check or request permissions for the foreground location.
- * This uses both `requestForegroundPermissionsAsync` and `getForegroundPermissionsAsync` to interact with the permissions.
- *
- * @example
- * ```ts
- * const [status, requestPermission] = Location.useForegroundPermissions();
- * ```
- */
-export const useForegroundPermissions = createPermissionHook({
-    getMethod: getForegroundPermissionsAsync,
-    requestMethod: requestForegroundPermissionsAsync,
-});
-// @needsAudit
-/**
- * Checks user's permissions for accessing location while the app is in the background.
- * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).
- */
-export async function getBackgroundPermissionsAsync() {
-    return await ExpoLocation.getBackgroundPermissionsAsync();
-}
-// @needsAudit
-/**
- * Asks the user to grant permissions for location while the app is in the background.
- * On __Android 11 or higher__: this method will open the system settings page - before that happens
- * you should explain to the user why your application needs background location permission.
- * For example, you can use `Modal` component from `react-native` to do that.
- * > __Note__: Foreground permissions should be granted before asking for the background permissions
- * (your app can't obtain background permission without foreground permission).
- * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).
- */
-export async function requestBackgroundPermissionsAsync() {
-    return await ExpoLocation.requestBackgroundPermissionsAsync();
-}
-// @needsAudit
-/**
- * Check or request permissions for the background location.
- * This uses both `requestBackgroundPermissionsAsync` and `getBackgroundPermissionsAsync` to
- * interact with the permissions.
- *
- * @example
- * ```ts
- * const [status, requestPermission] = Location.useBackgroundPermissions();
- * ```
- */
-export const useBackgroundPermissions = createPermissionHook({
-    getMethod: getBackgroundPermissionsAsync,
-    requestMethod: requestBackgroundPermissionsAsync,
-});
-// --- Location service
-// @needsAudit
-/**
- * Checks whether location services are enabled by the user.
- * @return A promise which fulfills to `true` if location services are enabled on the device,
- * or `false` if not.
- */
-export async function hasServicesEnabledAsync() {
-    return await ExpoLocation.hasServicesEnabledAsync();
-}
-// --- Background location updates
-function _validateTaskName(taskName) {
-    if (!taskName || typeof taskName !== 'string') {
-        throw new Error(`\`taskName\` must be a non-empty string. Got ${taskName} instead.`);
-    }
-}
-// @docsMissing
-export async function isBackgroundLocationAvailableAsync() {
-    const providerStatus = await getProviderStatusAsync();
-    return providerStatus.backgroundModeEnabled;
-}
-// @needsAudit
-/**
- * Registers for receiving location updates that can also come when the app is in the background.
- *
- * # Task parameters
- *
- * Background location task will be receiving following data:
- * - `locations` - An array of the new locations.
- *
- * ```ts
- * import * as TaskManager from 'expo-task-manager';
- *
- * TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { locations }, error }) => {
- *  if (error) {
- *    // check `error.message` for more details.
- *    return;
- *  }
- *  console.log('Received new locations', locations);
- * });
- * ```
- *
- * @param taskName Name of the task receiving location updates.
- * @param options An object of options passed to the location manager.
- *
- * @return A promise resolving once the task with location updates is registered.
- */
-export async function startLocationUpdatesAsync(taskName, options = { accuracy: LocationAccuracy.Balanced }) {
-    _validateTaskName(taskName);
-    await ExpoLocation.startLocationUpdatesAsync(taskName, options);
-}
-// @needsAudit
-/**
- * Stops geofencing for specified task.
- * @param taskName Name of the background location task to stop.
- * @return A promise resolving as soon as the task is unregistered.
- */
-export async function stopLocationUpdatesAsync(taskName) {
-    _validateTaskName(taskName);
-    await ExpoLocation.stopLocationUpdatesAsync(taskName);
-}
-// @needsAudit
-/**
- * @param taskName Name of the location task to check.
- * @return A promise which fulfills with boolean value indicating whether the location task is
- * started or not.
- */
-export async function hasStartedLocationUpdatesAsync(taskName) {
-    _validateTaskName(taskName);
-    return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);
-}
-// --- Geofencing
-function _validateRegions(regions) {
-    if (!regions || regions.length === 0) {
-        throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');
-    }
-    for (const region of regions) {
-        if (typeof region.latitude !== 'number') {
-            throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);
-        }
-        if (typeof region.longitude !== 'number') {
-            throw new TypeError(`Region's longitude must be a number. Got '${region.longitude}' instead.`);
-        }
-        if (typeof region.radius !== 'number') {
-            throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);
-        }
-    }
-}
-// @needsAudit
-/**
- * Starts geofencing for given regions. When the new event comes, the task with specified name will
- * be called with the region that the device enter to or exit from.
- * If you want to add or remove regions from already running geofencing task, you can just call
- * `startGeofencingAsync` again with the new array of regions.
- *
- * # Task parameters
- *
- * Geofencing task will be receiving following data:
- *  - `eventType` - Indicates the reason for calling the task, which can be triggered by entering or exiting the region.
- *    See [GeofencingEventType](#geofencingeventtype).
- *  - `region` - Object containing details about updated region. See [LocationRegion](#locationregion) for more details.
- *
- * @param taskName Name of the task that will be called when the device enters or exits from specified regions.
- * @param regions Array of region objects to be geofenced.
- *
- * @return A promise resolving as soon as the task is registered.
- *
- * @example
- * ```ts
- * import { GeofencingEventType } from 'expo-location';
- * import * as TaskManager from 'expo-task-manager';
- *
- *  TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { eventType, region }, error }) => {
- *   if (error) {
- *     // check `error.message` for more details.
- *     return;
- *   }
- *   if (eventType === GeofencingEventType.Enter) {
- *     console.log("You've entered region:", region);
- *   } else if (eventType === GeofencingEventType.Exit) {
- *     console.log("You've left region:", region);
- *   }
- * });
- * ```
- */
-export async function startGeofencingAsync(taskName, regions = []) {
-    _validateTaskName(taskName);
-    _validateRegions(regions);
-    await ExpoLocation.startGeofencingAsync(taskName, { regions });
-}
-// @needsAudit
-/**
- * Stops geofencing for specified task. It unregisters the background task so the app will not be
- * receiving any updates, especially in the background.
- * @param taskName Name of the task to unregister.
- * @return A promise resolving as soon as the task is unregistered.
- */
-export async function stopGeofencingAsync(taskName) {
-    _validateTaskName(taskName);
-    await ExpoLocation.stopGeofencingAsync(taskName);
-}
-// @needsAudit
-/**
- * @param taskName Name of the geofencing task to check.
- * @return A promise which fulfills with boolean value indicating whether the geofencing task is
- * started or not.
- */
-export async function hasStartedGeofencingAsync(taskName) {
-    _validateTaskName(taskName);
-    return ExpoLocation.hasStartedGeofencingAsync(taskName);
-}
-export { LocationEventEmitter as EventEmitter, _getCurrentWatchId };
-export { LocationAccuracy as Accuracy, LocationActivityType as ActivityType, LocationGeofencingEventType as GeofencingEventType, LocationGeofencingRegionState as GeofencingRegionState, PermissionStatus, setGoogleApiKey, };
-export { installWebGeolocationPolyfill } from './GeolocationPolyfill';
-export * from './Location.types';
-//# sourceMappingURL=Location.js.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/Location.js.map b/node_modules/expo-location/build/Location.js.map
deleted file mode 100644
index ffe9d7d..0000000
--- a/node_modules/expo-location/build/Location.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Location.js","sourceRoot":"","sources":["../src/Location.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  PermissionStatus,\n  PermissionResponse,\n  PermissionHookOptions,\n  createPermissionHook,\n  Platform,\n} from 'expo-modules-core';\n\nimport ExpoLocation from './ExpoLocation';\nimport {\n  LocationAccuracy,\n  LocationCallback,\n  LocationGeocodedAddress,\n  LocationGeocodedLocation,\n  LocationHeadingCallback,\n  LocationHeadingObject,\n  LocationLastKnownOptions,\n  LocationObject,\n  LocationOptions,\n  LocationPermissionResponse,\n  LocationProviderStatus,\n  LocationRegion,\n  LocationSubscription,\n  LocationTaskOptions,\n  LocationActivityType,\n  LocationGeofencingEventType,\n  LocationGeofencingRegionState,\n  LocationGeocodingOptions,\n} from './Location.types';\nimport { LocationEventEmitter } from './LocationEventEmitter';\nimport { LocationSubscriber, HeadingSubscriber, _getCurrentWatchId } from './LocationSubscribers';\n\n// @needsAudit\n/**\n * @deprecated The Geocoding web api is no longer available from SDK 49 onwards. Use [Place Autocomplete](https://developers.google.com/maps/documentation/places/web-service/autocomplete) instead.\n * @param apiKey Google API key obtained from Google API Console. This API key must have `Geocoding API`\n * enabled, otherwise your geocoding requests will be denied.\n */\nfunction setGoogleApiKey(_apiKey: string) {}\n\n// @needsAudit\n/**\n * Check status of location providers.\n * @return A promise which fulfills with an object of type [LocationProviderStatus](#locationproviderstatus).\n */\nexport async function getProviderStatusAsync(): Promise<LocationProviderStatus> {\n  return ExpoLocation.getProviderStatusAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to turn on high accuracy location mode which enables network provider that uses\n * Google Play services to improve location accuracy and location-based services.\n * @return A promise resolving as soon as the user accepts the dialog. Rejects if denied.\n */\nexport async function enableNetworkProviderAsync(): Promise<void> {\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\n  // Android's location provider may not give you any results. Use this method in order to ask the user\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n\n  if (Platform.OS === 'android') {\n    return ExpoLocation.enableNetworkProviderAsync();\n  }\n}\n\n// @needsAudit\n/**\n * Requests for one-time delivery of the user's current location.\n * Depending on given `accuracy` option it may take some time to resolve,\n * especially when you're inside a building.\n * > __Note:__ Calling it causes the location manager to obtain a location fix which may take several\n * > seconds. Consider using [`Location.getLastKnownPositionAsync`](#locationgetlastknownpositionasyncoptions)\n * > if you expect to get a quick response and high accuracy is not required.\n * @param options\n * @return A promise which fulfills with an object of type [`LocationObject`](#locationobject).\n */\nexport async function getCurrentPositionAsync(\n  options: LocationOptions = {}\n): Promise<LocationObject> {\n  return ExpoLocation.getCurrentPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Gets the last known position of the device or `null` if it's not available or doesn't match given\n * requirements such as maximum age or required accuracy.\n * It's considered to be faster than `getCurrentPositionAsync` as it doesn't request for the current\n * location, but keep in mind the returned location may not be up-to-date.\n * @param options\n * @return A promise which fulfills with an object of type [LocationObject](#locationobject) or\n * `null` if it's not available or doesn't match given requirements such as maximum age or required\n * accuracy.\n */\nexport async function getLastKnownPositionAsync(\n  options: LocationLastKnownOptions = {}\n): Promise<LocationObject | null> {\n  return ExpoLocation.getLastKnownPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Subscribe to location updates from the device. Please note that updates will only occur while the\n * application is in the foreground. To get location updates while in background you'll need to use\n * [Location.startLocationUpdatesAsync](#locationstartlocationupdatesasynctaskname-options).\n * @param options\n * @param callback This function is called on each location update. It receives an object of type\n * [`LocationObject`](#locationobject) as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchPositionAsync(\n  options: LocationOptions,\n  callback: LocationCallback\n): Promise<LocationSubscription> {\n  const watchId = LocationSubscriber.registerCallback(callback);\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\n\n  return {\n    remove() {\n      LocationSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Gets the current heading information from the device. To simplify, it calls `watchHeadingAsync`\n * and waits for a couple of updates, and then returns the one that is accurate enough.\n * @return A promise which fulfills with an object of type [LocationHeadingObject](#locationheadingobject).\n */\nexport async function getHeadingAsync(): Promise<LocationHeadingObject> {\n  return new Promise(async (resolve) => {\n    let tries = 0;\n\n    const subscription = await watchHeadingAsync((heading) => {\n      if (heading.accuracy > 1 || tries > 5) {\n        subscription.remove();\n        resolve(heading);\n      } else {\n        tries += 1;\n      }\n    });\n  });\n}\n\n// @needsAudit\n/**\n * Subscribe to compass updates from the device.\n * @param callback This function is called on each compass update. It receives an object of type\n * [LocationHeadingObject](#locationheadingobject) as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchHeadingAsync(\n  callback: LocationHeadingCallback\n): Promise<LocationSubscription> {\n  const watchId = HeadingSubscriber.registerCallback(callback);\n  await ExpoLocation.watchDeviceHeading(watchId);\n\n  return {\n    remove() {\n      HeadingSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Geocode an address string to latitude-longitude location.\n * > **Note**: Using the Geocoding web api is no longer supported. Use [Place Autocomplete](https://developers.google.com/maps/documentation/places/web-service/autocomplete) instead.\n *\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\n * > before geocoding can be used.\n * @param address A string representing address, eg. `\"Baker Street London\"`.\n * @param options\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedLocation`](#locationgeocodedlocation) objects.\n */\nexport async function geocodeAsync(\n  address: string,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedLocation[]> {\n  if (typeof address !== 'string') {\n    throw new TypeError(`Address to geocode must be a string. Got ${address} instead.`);\n  }\n\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    if (__DEV__) {\n      console.warn(\n        'The Geocoding API has been removed in SDK 49, use Place Autocomplete service instead' +\n          '(https://developers.google.com/maps/documentation/places/web-service/autocomplete)'\n      );\n    }\n    return [];\n  }\n\n  return await ExpoLocation.geocodeAsync(address);\n}\n\n// @needsAudit\n/**\n * Reverse geocode a location to postal address.\n * > **Note**: Using the Geocoding web api is no longer supported. Use [Place Autocomplete](https://developers.google.com/maps/documentation/places/web-service/autocomplete) instead.\n *\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\n * > before geocoding can be used.\n * @param location An object representing a location.\n * @param options\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedAddress`](#locationgeocodedaddress) objects.\n */\nexport async function reverseGeocodeAsync(\n  location: Pick<LocationGeocodedLocation, 'latitude' | 'longitude'>,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedAddress[]> {\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n    throw new TypeError(\n      'Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.'\n    );\n  }\n\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    if (__DEV__) {\n      console.warn(\n        'The Geocoding API has been removed in SDK 49, use Place Autocomplete service instead' +\n          '(https://developers.google.com/maps/documentation/places/web-service/autocomplete)'\n      );\n    }\n    return [];\n  }\n\n  return await ExpoLocation.reverseGeocodeAsync(location);\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location.\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\n * @deprecated Use [`getForegroundPermissionsAsync`](#locationgetforegroundpermissionsasync) or [`getBackgroundPermissionsAsync`](#locationgetbackgroundpermissionsasync) instead.\n */\nexport async function getPermissionsAsync(): Promise<LocationPermissionResponse> {\n  console.warn(\n    `\"getPermissionsAsync()\" is now deprecated. Please use \"getForegroundPermissionsAsync()\" or \"getBackgroundPermissionsAsync()\" instead.`\n  );\n  return await ExpoLocation.getPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location.\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\n * @deprecated Use [`requestForegroundPermissionsAsync`](#locationrequestforegroundpermissionsasync) or [`requestBackgroundPermissionsAsync`](#locationrequestbackgroundpermissionsasync) instead.\n */\nexport async function requestPermissionsAsync(): Promise<LocationPermissionResponse> {\n  console.warn(\n    `\"requestPermissionsAsync()\" is now deprecated. Please use \"requestForegroundPermissionsAsync()\" or \"requestBackgroundPermissionsAsync()\" instead.`\n  );\n\n  return await ExpoLocation.requestPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function getForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.getForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function requestForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.requestForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the foreground location.\n * This uses both `requestForegroundPermissionsAsync` and `getForegroundPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useForegroundPermissions();\n * ```\n */\nexport const useForegroundPermissions = createPermissionHook({\n  getMethod: getForegroundPermissionsAsync,\n  requestMethod: requestForegroundPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the background.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function getBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.getBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the background.\n * On __Android 11 or higher__: this method will open the system settings page - before that happens\n * you should explain to the user why your application needs background location permission.\n * For example, you can use `Modal` component from `react-native` to do that.\n * > __Note__: Foreground permissions should be granted before asking for the background permissions\n * (your app can't obtain background permission without foreground permission).\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function requestBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.requestBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the background location.\n * This uses both `requestBackgroundPermissionsAsync` and `getBackgroundPermissionsAsync` to\n * interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useBackgroundPermissions();\n * ```\n */\nexport const useBackgroundPermissions = createPermissionHook({\n  getMethod: getBackgroundPermissionsAsync,\n  requestMethod: requestBackgroundPermissionsAsync,\n});\n\n// --- Location service\n\n// @needsAudit\n/**\n * Checks whether location services are enabled by the user.\n * @return A promise which fulfills to `true` if location services are enabled on the device,\n * or `false` if not.\n */\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\n  return await ExpoLocation.hasServicesEnabledAsync();\n}\n\n// --- Background location updates\n\nfunction _validateTaskName(taskName: string) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(`\\`taskName\\` must be a non-empty string. Got ${taskName} instead.`);\n  }\n}\n\n// @docsMissing\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\n  const providerStatus = await getProviderStatusAsync();\n  return providerStatus.backgroundModeEnabled;\n}\n\n// @needsAudit\n/**\n * Registers for receiving location updates that can also come when the app is in the background.\n *\n * # Task parameters\n *\n * Background location task will be receiving following data:\n * - `locations` - An array of the new locations.\n *\n * ```ts\n * import * as TaskManager from 'expo-task-manager';\n *\n * TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { locations }, error }) => {\n *  if (error) {\n *    // check `error.message` for more details.\n *    return;\n *  }\n *  console.log('Received new locations', locations);\n * });\n * ```\n *\n * @param taskName Name of the task receiving location updates.\n * @param options An object of options passed to the location manager.\n *\n * @return A promise resolving once the task with location updates is registered.\n */\nexport async function startLocationUpdatesAsync(\n  taskName: string,\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\n): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task.\n * @param taskName Name of the background location task to stop.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the location task to check.\n * @return A promise which fulfills with boolean value indicating whether the location task is\n * started or not.\n */\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n}\n\n// --- Geofencing\n\nfunction _validateRegions(regions: LocationRegion[]) {\n  if (!regions || regions.length === 0) {\n    throw new Error(\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\n    );\n  }\n  for (const region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\n      );\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\n\n// @needsAudit\n/**\n * Starts geofencing for given regions. When the new event comes, the task with specified name will\n * be called with the region that the device enter to or exit from.\n * If you want to add or remove regions from already running geofencing task, you can just call\n * `startGeofencingAsync` again with the new array of regions.\n *\n * # Task parameters\n *\n * Geofencing task will be receiving following data:\n *  - `eventType` - Indicates the reason for calling the task, which can be triggered by entering or exiting the region.\n *    See [GeofencingEventType](#geofencingeventtype).\n *  - `region` - Object containing details about updated region. See [LocationRegion](#locationregion) for more details.\n *\n * @param taskName Name of the task that will be called when the device enters or exits from specified regions.\n * @param regions Array of region objects to be geofenced.\n *\n * @return A promise resolving as soon as the task is registered.\n *\n * @example\n * ```ts\n * import { GeofencingEventType } from 'expo-location';\n * import * as TaskManager from 'expo-task-manager';\n *\n *  TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { eventType, region }, error }) => {\n *   if (error) {\n *     // check `error.message` for more details.\n *     return;\n *   }\n *   if (eventType === GeofencingEventType.Enter) {\n *     console.log(\"You've entered region:\", region);\n *   } else if (eventType === GeofencingEventType.Exit) {\n *     console.log(\"You've left region:\", region);\n *   }\n * });\n * ```\n */\nexport async function startGeofencingAsync(\n  taskName: string,\n  regions: LocationRegion[] = []\n): Promise<void> {\n  _validateTaskName(taskName);\n  _validateRegions(regions);\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task. It unregisters the background task so the app will not be\n * receiving any updates, especially in the background.\n * @param taskName Name of the task to unregister.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopGeofencingAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the geofencing task to check.\n * @return A promise which fulfills with boolean value indicating whether the geofencing task is\n * started or not.\n */\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\n}\n\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };\n\nexport {\n  LocationAccuracy as Accuracy,\n  LocationActivityType as ActivityType,\n  LocationGeofencingEventType as GeofencingEventType,\n  LocationGeofencingRegionState as GeofencingRegionState,\n  PermissionStatus,\n  PermissionHookOptions,\n  setGoogleApiKey,\n};\n\nexport { installWebGeolocationPolyfill } from './GeolocationPolyfill';\nexport * from './Location.types';\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/Location.types.d.ts b/node_modules/expo-location/build/Location.types.d.ts
deleted file mode 100644
index edcb1e0..0000000
--- a/node_modules/expo-location/build/Location.types.d.ts
+++ /dev/null
@@ -1,458 +0,0 @@
-import { PermissionResponse } from 'expo-modules-core';
-/**
- * Enum with available location accuracies.
- */
-export declare enum LocationAccuracy {
-    /**
-     * Accurate to the nearest three kilometers.
-     */
-    Lowest = 1,
-    /**
-     * Accurate to the nearest kilometer.
-     */
-    Low = 2,
-    /**
-     * Accurate to within one hundred meters.
-     */
-    Balanced = 3,
-    /**
-     * Accurate to within ten meters of the desired target.
-     */
-    High = 4,
-    /**
-     * The best level of accuracy available.
-     */
-    Highest = 5,
-    /**
-     * The highest possible accuracy that uses additional sensor data to facilitate navigation apps.
-     */
-    BestForNavigation = 6
-}
-/**
- * Enum with available activity types of background location tracking.
- */
-export declare enum LocationActivityType {
-    /**
-     * Default activity type. Use it if there is no other type that matches the activity you track.
-     */
-    Other = 1,
-    /**
-     * Location updates are being used specifically during vehicular navigation to track location
-     * changes to the automobile.
-     */
-    AutomotiveNavigation = 2,
-    /**
-     * Use this activity type if you track fitness activities such as walking, running, cycling,
-     * and so on.
-     */
-    Fitness = 3,
-    /**
-     * Activity type for movements for other types of vehicular navigation that are not automobile
-     * related.
-     */
-    OtherNavigation = 4,
-    /**
-     * Intended for airborne activities. Fall backs to `ActivityType.Other` if
-     * unsupported.
-     * @platform ios 12+
-     */
-    Airborne = 5
-}
-/**
- * A type of the event that geofencing task can receive.
- */
-export declare enum LocationGeofencingEventType {
-    /**
-     * Emitted when the device entered observed region.
-     */
-    Enter = 1,
-    /**
-     * Occurs as soon as the device left observed region
-     */
-    Exit = 2
-}
-/**
- * State of the geofencing region that you receive through the geofencing task.
- */
-export declare enum LocationGeofencingRegionState {
-    /**
-     * Indicates that the device position related to the region is unknown.
-     */
-    Unknown = 0,
-    /**
-     * Indicates that the device is inside the region.
-     */
-    Inside = 1,
-    /**
-     * Inverse of inside state.
-     */
-    Outside = 2
-}
-/**
- * Type representing options argument in `getCurrentPositionAsync`.
- */
-export type LocationOptions = {
-    /**
-     * Location manager accuracy. Pass one of `Accuracy` enum values.
-     * For low-accuracies the implementation can avoid geolocation providers
-     * that consume a significant amount of power (such as GPS).
-     */
-    accuracy?: LocationAccuracy;
-    /**
-     * Specifies whether to ask the user to turn on improved accuracy location mode
-     * which uses Wi-Fi, cell networks and GPS sensor.
-     * @default true
-     * @platform android
-     */
-    mayShowUserSettingsDialog?: boolean;
-    /**
-     * Minimum time to wait between each update in milliseconds.
-     * Default value may depend on `accuracy` option.
-     * @platform android
-     */
-    timeInterval?: number;
-    /**
-     * Receive updates only when the location has changed by at least this distance in meters.
-     * Default value may depend on `accuracy` option.
-     */
-    distanceInterval?: number;
-};
-/**
- * Type representing options object that can be passed to `getLastKnownPositionAsync`.
- */
-export type LocationLastKnownOptions = {
-    /**
-     * A number of milliseconds after which the last known location starts to be invalid and thus
-     * `null` is returned.
-     */
-    maxAge?: number;
-    /**
-     * The maximum radius of uncertainty for the location, measured in meters. If the last known
-     * location's accuracy radius is bigger (less accurate) then `null` is returned.
-     */
-    requiredAccuracy?: number;
-};
-/**
- * Type representing background location task options.
- */
-export type LocationTaskOptions = LocationOptions & {
-    /**
-     * A boolean indicating whether the status bar changes its appearance when
-     * location services are used in the background.
-     * @default false
-     * @platform ios 11+
-     */
-    showsBackgroundLocationIndicator?: boolean;
-    /**
-     * The distance in meters that must occur between last reported location and the current location
-     * before deferred locations are reported.
-     * @default 0
-     */
-    deferredUpdatesDistance?: number;
-    deferredUpdatesTimeout?: number;
-    /**
-     * Minimum time interval in milliseconds that must pass since last reported location before all
-     * later locations are reported in a batched update
-     * @default 0
-     */
-    deferredUpdatesInterval?: number;
-    /**
-     * The type of user activity associated with the location updates.
-     * @see See [Apple docs](https://developer.apple.com/documentation/corelocation/cllocationmanager/1620567-activitytype) for more details.
-     * @default ActivityType.Other
-     * @platform ios
-     */
-    activityType?: LocationActivityType;
-    /**
-     * A boolean value indicating whether the location manager can pause location
-     * updates to improve battery life without sacrificing location data. When this option is set to
-     * `true`, the location manager pauses updates (and powers down the appropriate hardware) at times
-     * when the location data is unlikely to change. You can help the determination of when to pause
-     * location updates by assigning a value to the `activityType` property.
-     * @default false
-     * @platform ios
-     */
-    pausesUpdatesAutomatically?: boolean;
-    foregroundService?: LocationTaskServiceOptions;
-};
-export type LocationTaskServiceOptions = {
-    /**
-     * Title of the foreground service notification.
-     */
-    notificationTitle: string;
-    /**
-     * Subtitle of the foreground service notification.
-     */
-    notificationBody: string;
-    /**
-     * Color of the foreground service notification. Accepts `#RRGGBB` and `#AARRGGBB` hex formats.
-     */
-    notificationColor?: string;
-    /**
-     * Boolean value whether to destroy the foreground service if the app is killed.
-     */
-    killServiceOnDestroy?: boolean;
-};
-/**
- * Type representing geofencing region object.
- */
-export type LocationRegion = {
-    /**
-     * The identifier of the region object. Defaults to auto-generated UUID hash.
-     */
-    identifier?: string;
-    /**
-     * The latitude in degrees of region's center point.
-     */
-    latitude: number;
-    /**
-     * The longitude in degrees of region's center point.
-     */
-    longitude: number;
-    /**
-     * The radius measured in meters that defines the region's outer boundary.
-     */
-    radius: number;
-    /**
-     * Boolean value whether to call the task if the device enters the region.
-     * @default true
-     */
-    notifyOnEnter?: boolean;
-    /**
-     * Boolean value whether to call the task if the device exits the region.
-     * @default true
-     */
-    notifyOnExit?: boolean;
-    /**
-     * One of [GeofencingRegionState](#geofencingregionstate) region state. Determines whether the
-     * device is inside or outside a region.
-     */
-    state?: LocationGeofencingRegionState;
-};
-/**
- * Type representing the location object.
- */
-export type LocationObject = {
-    /**
-     * The coordinates of the position.
-     */
-    coords: LocationObjectCoords;
-    /**
-     * The time at which this position information was obtained, in milliseconds since epoch.
-     */
-    timestamp: number;
-    /**
-     * Whether the location coordinates is mocked or not.
-     * @platform android
-     */
-    mocked?: boolean;
-};
-/**
- * Type representing the location GPS related data.
- */
-export type LocationObjectCoords = {
-    /**
-     * The latitude in degrees.
-     */
-    latitude: number;
-    /**
-     * The longitude in degrees.
-     */
-    longitude: number;
-    /**
-     * The altitude in meters above the WGS 84 reference ellipsoid. Can be `null` on Web if it's not available.
-     */
-    altitude: number | null;
-    /**
-     * The radius of uncertainty for the location, measured in meters. Can be `null` on Web if it's not available.
-     */
-    accuracy: number | null;
-    /**
-     * The accuracy of the altitude value, in meters. Can be `null` on Web if it's not available.
-     */
-    altitudeAccuracy: number | null;
-    /**
-     * Horizontal direction of travel of this device, measured in degrees starting at due north and
-     * continuing clockwise around the compass. Thus, north is 0 degrees, east is 90 degrees, south is
-     * 180 degrees, and so on. Can be `null` on Web if it's not available.
-     */
-    heading: number | null;
-    /**
-     * The instantaneous speed of the device in meters per second. Can be `null` on Web if it's not available.
-     */
-    speed: number | null;
-};
-/**
- * Represents `watchPositionAsync` callback.
- */
-export type LocationCallback = (location: LocationObject) => any;
-/**
- * Represents the object containing details about location provider.
- */
-export type LocationProviderStatus = {
-    /**
-     * Whether location services are enabled. See [Location.hasServicesEnabledAsync](#locationhasservicesenabledasync)
-     * for a more convenient solution to get this value.
-     */
-    locationServicesEnabled: boolean;
-    backgroundModeEnabled: boolean;
-    /**
-     * Whether the GPS provider is available. If `true` the location data will come
-     * from GPS, especially for requests with high accuracy.
-     * @platform android
-     */
-    gpsAvailable?: boolean;
-    /**
-     * Whether the network provider is available. If `true` the location data will
-     * come from cellular network, especially for requests with low accuracy.
-     * @platform android
-     */
-    networkAvailable?: boolean;
-    /**
-     * Whether the passive provider is available. If `true` the location data will
-     * be determined passively.
-     * @platform android
-     */
-    passiveAvailable?: boolean;
-};
-/**
- * Type of the object containing heading details and provided by `watchHeadingAsync` callback.
- */
-export type LocationHeadingObject = {
-    /**
-     * Measure of true north in degrees (needs location permissions, will return `-1` if not given).
-     */
-    trueHeading: number;
-    /**
-     * Measure of magnetic north in degrees.
-     */
-    magHeading: number;
-    /**
-     * Level of calibration of compass.
-     * - `3`: high accuracy, `2`: medium accuracy, `1`: low accuracy, `0`: none
-     * Reference for iOS:
-     * - `3`: < 20 degrees uncertainty, `2`: < 35 degrees, `1`: < 50 degrees, `0`: > 50 degrees
-     */
-    accuracy: number;
-};
-/**
- * Represents `watchHeadingAsync` callback.
- */
-export type LocationHeadingCallback = (location: LocationHeadingObject) => any;
-/**
- * An object of options for forward and reverse geocoding.
- */
-export type LocationGeocodingOptions = {
-    /**
-     * Whether to force using Google Maps API instead of the native implementation.
-     * Used by default only on Web platform. Requires providing an API key by `setGoogleApiKey`.
-     */
-    useGoogleMaps?: boolean;
-};
-/**
- * Type representing a result of `geocodeAsync`.
- */
-export type LocationGeocodedLocation = {
-    /**
-     * The latitude in degrees.
-     */
-    latitude: number;
-    /**
-     * The longitude in degrees.
-     */
-    longitude: number;
-    /**
-     * The altitude in meters above the WGS 84 reference ellipsoid.
-     */
-    altitude?: number;
-    /**
-     * The radius of uncertainty for the location, measured in meters.
-     */
-    accuracy?: number;
-};
-/**
- * Type representing a result of `reverseGeocodeAsync`.
- */
-export type LocationGeocodedAddress = {
-    /**
-     * City name of the address.
-     */
-    city: string | null;
-    /**
-     * Additional city-level information like district name.
-     */
-    district: string | null;
-    /**
-     * Street number of the address.
-     */
-    streetNumber: string | null;
-    /**
-     * Street name of the address.
-     */
-    street: string | null;
-    /**
-     * The state or province associated with the address.
-     */
-    region: string | null;
-    /**
-     * Additional information about administrative area.
-     */
-    subregion: string | null;
-    /**
-     * Localized country name of the address.
-     */
-    country: string | null;
-    /**
-     * Postal code of the address.
-     */
-    postalCode: string | null;
-    /**
-     * The name of the placemark, for example, "Tower Bridge".
-     */
-    name: string | null;
-    /**
-     * Localized (ISO) country code of the address, if available.
-     */
-    isoCountryCode: string | null;
-    /**
-     * The timezone identifier associated with the address.
-     * @platform ios
-     */
-    timezone: string | null;
-};
-/**
- * Represents subscription object returned by methods watching for new locations or headings.
- */
-export type LocationSubscription = {
-    /**
-     * Call this function with no arguments to remove this subscription. The callback will no longer
-     * be called for location updates.
-     */
-    remove: () => void;
-};
-export type PermissionDetailsLocationIOS = {
-    /**
-     * The scope of granted permission. Indicates when it's possible to use location.
-     */
-    scope: 'whenInUse' | 'always' | 'none';
-};
-export type PermissionDetailsLocationAndroid = {
-    /**
-     * @deprecated Use `accuracy` field instead.
-     */
-    scope: 'fine' | 'coarse' | 'none';
-    /**
-     * Indicates the type of location provider.
-     */
-    accuracy: 'fine' | 'coarse' | 'none';
-};
-/**
- * `LocationPermissionResponse` extends [PermissionResponse](#permissionresponse)
- * type exported by `expo-modules-core` and contains additional platform-specific fields.
- */
-export type LocationPermissionResponse = PermissionResponse & {
-    ios?: PermissionDetailsLocationIOS;
-    android?: PermissionDetailsLocationAndroid;
-};
-export type { PermissionResponse };
-//# sourceMappingURL=Location.types.d.ts.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/Location.types.d.ts.map b/node_modules/expo-location/build/Location.types.d.ts.map
deleted file mode 100644
index ad0f05b..0000000
--- a/node_modules/expo-location/build/Location.types.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Location.types.d.ts","sourceRoot":"","sources":["../src/Location.types.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/Location.types.js b/node_modules/expo-location/build/Location.types.js
deleted file mode 100644
index 5cd335b..0000000
--- a/node_modules/expo-location/build/Location.types.js
+++ /dev/null
@@ -1,98 +0,0 @@
-// @needsAudit
-/**
- * Enum with available location accuracies.
- */
-export var LocationAccuracy;
-(function (LocationAccuracy) {
-    /**
-     * Accurate to the nearest three kilometers.
-     */
-    LocationAccuracy[LocationAccuracy["Lowest"] = 1] = "Lowest";
-    /**
-     * Accurate to the nearest kilometer.
-     */
-    LocationAccuracy[LocationAccuracy["Low"] = 2] = "Low";
-    /**
-     * Accurate to within one hundred meters.
-     */
-    LocationAccuracy[LocationAccuracy["Balanced"] = 3] = "Balanced";
-    /**
-     * Accurate to within ten meters of the desired target.
-     */
-    LocationAccuracy[LocationAccuracy["High"] = 4] = "High";
-    /**
-     * The best level of accuracy available.
-     */
-    LocationAccuracy[LocationAccuracy["Highest"] = 5] = "Highest";
-    /**
-     * The highest possible accuracy that uses additional sensor data to facilitate navigation apps.
-     */
-    LocationAccuracy[LocationAccuracy["BestForNavigation"] = 6] = "BestForNavigation";
-})(LocationAccuracy || (LocationAccuracy = {}));
-// @needsAudit
-/**
- * Enum with available activity types of background location tracking.
- */
-export var LocationActivityType;
-(function (LocationActivityType) {
-    /**
-     * Default activity type. Use it if there is no other type that matches the activity you track.
-     */
-    LocationActivityType[LocationActivityType["Other"] = 1] = "Other";
-    /**
-     * Location updates are being used specifically during vehicular navigation to track location
-     * changes to the automobile.
-     */
-    LocationActivityType[LocationActivityType["AutomotiveNavigation"] = 2] = "AutomotiveNavigation";
-    /**
-     * Use this activity type if you track fitness activities such as walking, running, cycling,
-     * and so on.
-     */
-    LocationActivityType[LocationActivityType["Fitness"] = 3] = "Fitness";
-    /**
-     * Activity type for movements for other types of vehicular navigation that are not automobile
-     * related.
-     */
-    LocationActivityType[LocationActivityType["OtherNavigation"] = 4] = "OtherNavigation";
-    /**
-     * Intended for airborne activities. Fall backs to `ActivityType.Other` if
-     * unsupported.
-     * @platform ios 12+
-     */
-    LocationActivityType[LocationActivityType["Airborne"] = 5] = "Airborne";
-})(LocationActivityType || (LocationActivityType = {}));
-// @needsAudit
-/**
- * A type of the event that geofencing task can receive.
- */
-export var LocationGeofencingEventType;
-(function (LocationGeofencingEventType) {
-    /**
-     * Emitted when the device entered observed region.
-     */
-    LocationGeofencingEventType[LocationGeofencingEventType["Enter"] = 1] = "Enter";
-    /**
-     * Occurs as soon as the device left observed region
-     */
-    LocationGeofencingEventType[LocationGeofencingEventType["Exit"] = 2] = "Exit";
-})(LocationGeofencingEventType || (LocationGeofencingEventType = {}));
-// @needsAudit
-/**
- * State of the geofencing region that you receive through the geofencing task.
- */
-export var LocationGeofencingRegionState;
-(function (LocationGeofencingRegionState) {
-    /**
-     * Indicates that the device position related to the region is unknown.
-     */
-    LocationGeofencingRegionState[LocationGeofencingRegionState["Unknown"] = 0] = "Unknown";
-    /**
-     * Indicates that the device is inside the region.
-     */
-    LocationGeofencingRegionState[LocationGeofencingRegionState["Inside"] = 1] = "Inside";
-    /**
-     * Inverse of inside state.
-     */
-    LocationGeofencingRegionState[LocationGeofencingRegionState["Outside"] = 2] = "Outside";
-})(LocationGeofencingRegionState || (LocationGeofencingRegionState = {}));
-//# sourceMappingURL=Location.types.js.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/Location.types.js.map b/node_modules/expo-location/build/Location.types.js.map
deleted file mode 100644
index ca9b6cb..0000000
--- a/node_modules/expo-location/build/Location.types.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Location.types.js","sourceRoot":"","sources":["../src/Location.types.ts"],"names":[],"mappings":"AAEA,cAAc;AACd;;GAEG;AACH,MAAM,CAAN,IAAY,gBAyBX;AAzBD,WAAY,gBAAgB;IAC1B;;OAEG;IACH,2DAAU,CAAA;IACV;;OAEG;IACH,qDAAO,CAAA;IACP;;OAEG;IACH,+DAAY,CAAA;IACZ;;OAEG;IACH,uDAAQ,CAAA;IACR;;OAEG;IACH,6DAAW,CAAA;IACX;;OAEG;IACH,iFAAqB,CAAA;AACvB,CAAC,EAzBW,gBAAgB,KAAhB,gBAAgB,QAyB3B;AAED,cAAc;AACd;;GAEG;AACH,MAAM,CAAN,IAAY,oBA0BX;AA1BD,WAAY,oBAAoB;IAC9B;;OAEG;IACH,iEAAS,CAAA;IACT;;;OAGG;IACH,+FAAwB,CAAA;IACxB;;;OAGG;IACH,qEAAW,CAAA;IACX;;;OAGG;IACH,qFAAmB,CAAA;IACnB;;;;OAIG;IACH,uEAAY,CAAA;AACd,CAAC,EA1BW,oBAAoB,KAApB,oBAAoB,QA0B/B;AAED,cAAc;AACd;;GAEG;AACH,MAAM,CAAN,IAAY,2BASX;AATD,WAAY,2BAA2B;IACrC;;OAEG;IACH,+EAAS,CAAA;IACT;;OAEG;IACH,6EAAQ,CAAA;AACV,CAAC,EATW,2BAA2B,KAA3B,2BAA2B,QAStC;AAED,cAAc;AACd;;GAEG;AACH,MAAM,CAAN,IAAY,6BAaX;AAbD,WAAY,6BAA6B;IACvC;;OAEG;IACH,uFAAW,CAAA;IACX;;OAEG;IACH,qFAAU,CAAA;IACV;;OAEG;IACH,uFAAW,CAAA;AACb,CAAC,EAbW,6BAA6B,KAA7B,6BAA6B,QAaxC","sourcesContent":["import { PermissionResponse } from 'expo-modules-core';\n\n// @needsAudit\n/**\n * Enum with available location accuracies.\n */\nexport enum LocationAccuracy {\n  /**\n   * Accurate to the nearest three kilometers.\n   */\n  Lowest = 1,\n  /**\n   * Accurate to the nearest kilometer.\n   */\n  Low = 2,\n  /**\n   * Accurate to within one hundred meters.\n   */\n  Balanced = 3,\n  /**\n   * Accurate to within ten meters of the desired target.\n   */\n  High = 4,\n  /**\n   * The best level of accuracy available.\n   */\n  Highest = 5,\n  /**\n   * The highest possible accuracy that uses additional sensor data to facilitate navigation apps.\n   */\n  BestForNavigation = 6,\n}\n\n// @needsAudit\n/**\n * Enum with available activity types of background location tracking.\n */\nexport enum LocationActivityType {\n  /**\n   * Default activity type. Use it if there is no other type that matches the activity you track.\n   */\n  Other = 1,\n  /**\n   * Location updates are being used specifically during vehicular navigation to track location\n   * changes to the automobile.\n   */\n  AutomotiveNavigation = 2,\n  /**\n   * Use this activity type if you track fitness activities such as walking, running, cycling,\n   * and so on.\n   */\n  Fitness = 3,\n  /**\n   * Activity type for movements for other types of vehicular navigation that are not automobile\n   * related.\n   */\n  OtherNavigation = 4,\n  /**\n   * Intended for airborne activities. Fall backs to `ActivityType.Other` if\n   * unsupported.\n   * @platform ios 12+\n   */\n  Airborne = 5,\n}\n\n// @needsAudit\n/**\n * A type of the event that geofencing task can receive.\n */\nexport enum LocationGeofencingEventType {\n  /**\n   * Emitted when the device entered observed region.\n   */\n  Enter = 1,\n  /**\n   * Occurs as soon as the device left observed region\n   */\n  Exit = 2,\n}\n\n// @needsAudit\n/**\n * State of the geofencing region that you receive through the geofencing task.\n */\nexport enum LocationGeofencingRegionState {\n  /**\n   * Indicates that the device position related to the region is unknown.\n   */\n  Unknown = 0,\n  /**\n   * Indicates that the device is inside the region.\n   */\n  Inside = 1,\n  /**\n   * Inverse of inside state.\n   */\n  Outside = 2,\n}\n\n// @needsAudit\n/**\n * Type representing options argument in `getCurrentPositionAsync`.\n */\nexport type LocationOptions = {\n  /**\n   * Location manager accuracy. Pass one of `Accuracy` enum values.\n   * For low-accuracies the implementation can avoid geolocation providers\n   * that consume a significant amount of power (such as GPS).\n   */\n  accuracy?: LocationAccuracy;\n  /**\n   * Specifies whether to ask the user to turn on improved accuracy location mode\n   * which uses Wi-Fi, cell networks and GPS sensor.\n   * @default true\n   * @platform android\n   */\n  mayShowUserSettingsDialog?: boolean;\n  /**\n   * Minimum time to wait between each update in milliseconds.\n   * Default value may depend on `accuracy` option.\n   * @platform android\n   */\n  timeInterval?: number;\n  /**\n   * Receive updates only when the location has changed by at least this distance in meters.\n   * Default value may depend on `accuracy` option.\n   */\n  distanceInterval?: number;\n};\n\n// @needsAudit\n/**\n * Type representing options object that can be passed to `getLastKnownPositionAsync`.\n */\nexport type LocationLastKnownOptions = {\n  /**\n   * A number of milliseconds after which the last known location starts to be invalid and thus\n   * `null` is returned.\n   */\n  maxAge?: number;\n  /**\n   * The maximum radius of uncertainty for the location, measured in meters. If the last known\n   * location's accuracy radius is bigger (less accurate) then `null` is returned.\n   */\n  requiredAccuracy?: number;\n};\n\n// @needsAudit\n/**\n * Type representing background location task options.\n */\nexport type LocationTaskOptions = LocationOptions & {\n  /**\n   * A boolean indicating whether the status bar changes its appearance when\n   * location services are used in the background.\n   * @default false\n   * @platform ios 11+\n   */\n  showsBackgroundLocationIndicator?: boolean;\n  /**\n   * The distance in meters that must occur between last reported location and the current location\n   * before deferred locations are reported.\n   * @default 0\n   */\n  deferredUpdatesDistance?: number;\n  // @docsMissing\n  deferredUpdatesTimeout?: number;\n  /**\n   * Minimum time interval in milliseconds that must pass since last reported location before all\n   * later locations are reported in a batched update\n   * @default 0\n   */\n  deferredUpdatesInterval?: number;\n  /**\n   * The type of user activity associated with the location updates.\n   * @see See [Apple docs](https://developer.apple.com/documentation/corelocation/cllocationmanager/1620567-activitytype) for more details.\n   * @default ActivityType.Other\n   * @platform ios\n   */\n  activityType?: LocationActivityType;\n  /**\n   * A boolean value indicating whether the location manager can pause location\n   * updates to improve battery life without sacrificing location data. When this option is set to\n   * `true`, the location manager pauses updates (and powers down the appropriate hardware) at times\n   * when the location data is unlikely to change. You can help the determination of when to pause\n   * location updates by assigning a value to the `activityType` property.\n   * @default false\n   * @platform ios\n   */\n  pausesUpdatesAutomatically?: boolean;\n  foregroundService?: LocationTaskServiceOptions;\n};\n\n// @needsAudit\nexport type LocationTaskServiceOptions = {\n  /**\n   * Title of the foreground service notification.\n   */\n  notificationTitle: string;\n  /**\n   * Subtitle of the foreground service notification.\n   */\n  notificationBody: string;\n  /**\n   * Color of the foreground service notification. Accepts `#RRGGBB` and `#AARRGGBB` hex formats.\n   */\n  notificationColor?: string;\n  /**\n   * Boolean value whether to destroy the foreground service if the app is killed.\n   */\n  killServiceOnDestroy?: boolean;\n};\n\n// @needsAudit\n/**\n * Type representing geofencing region object.\n */\nexport type LocationRegion = {\n  /**\n   * The identifier of the region object. Defaults to auto-generated UUID hash.\n   */\n  identifier?: string;\n  /**\n   * The latitude in degrees of region's center point.\n   */\n  latitude: number;\n  /**\n   * The longitude in degrees of region's center point.\n   */\n  longitude: number;\n  /**\n   * The radius measured in meters that defines the region's outer boundary.\n   */\n  radius: number;\n  /**\n   * Boolean value whether to call the task if the device enters the region.\n   * @default true\n   */\n  notifyOnEnter?: boolean;\n  /**\n   * Boolean value whether to call the task if the device exits the region.\n   * @default true\n   */\n  notifyOnExit?: boolean;\n  /**\n   * One of [GeofencingRegionState](#geofencingregionstate) region state. Determines whether the\n   * device is inside or outside a region.\n   */\n  state?: LocationGeofencingRegionState;\n};\n\n// @needsAudit\n/**\n * Type representing the location object.\n */\nexport type LocationObject = {\n  /**\n   * The coordinates of the position.\n   */\n  coords: LocationObjectCoords;\n  /**\n   * The time at which this position information was obtained, in milliseconds since epoch.\n   */\n  timestamp: number;\n  /**\n   * Whether the location coordinates is mocked or not.\n   * @platform android\n   */\n  mocked?: boolean;\n};\n\n// @needsAudit\n/**\n * Type representing the location GPS related data.\n */\nexport type LocationObjectCoords = {\n  /**\n   * The latitude in degrees.\n   */\n  latitude: number;\n  /**\n   * The longitude in degrees.\n   */\n  longitude: number;\n  /**\n   * The altitude in meters above the WGS 84 reference ellipsoid. Can be `null` on Web if it's not available.\n   */\n  altitude: number | null;\n  /**\n   * The radius of uncertainty for the location, measured in meters. Can be `null` on Web if it's not available.\n   */\n  accuracy: number | null;\n  /**\n   * The accuracy of the altitude value, in meters. Can be `null` on Web if it's not available.\n   */\n  altitudeAccuracy: number | null;\n  /**\n   * Horizontal direction of travel of this device, measured in degrees starting at due north and\n   * continuing clockwise around the compass. Thus, north is 0 degrees, east is 90 degrees, south is\n   * 180 degrees, and so on. Can be `null` on Web if it's not available.\n   */\n  heading: number | null;\n  /**\n   * The instantaneous speed of the device in meters per second. Can be `null` on Web if it's not available.\n   */\n  speed: number | null;\n};\n\n// @needsAudit\n/**\n * Represents `watchPositionAsync` callback.\n */\nexport type LocationCallback = (location: LocationObject) => any;\n\n// @needsAudit\n/**\n * Represents the object containing details about location provider.\n */\nexport type LocationProviderStatus = {\n  /**\n   * Whether location services are enabled. See [Location.hasServicesEnabledAsync](#locationhasservicesenabledasync)\n   * for a more convenient solution to get this value.\n   */\n  locationServicesEnabled: boolean;\n  // @docsMissing\n  backgroundModeEnabled: boolean;\n  /**\n   * Whether the GPS provider is available. If `true` the location data will come\n   * from GPS, especially for requests with high accuracy.\n   * @platform android\n   */\n  gpsAvailable?: boolean;\n  /**\n   * Whether the network provider is available. If `true` the location data will\n   * come from cellular network, especially for requests with low accuracy.\n   * @platform android\n   */\n  networkAvailable?: boolean;\n  /**\n   * Whether the passive provider is available. If `true` the location data will\n   * be determined passively.\n   * @platform android\n   */\n  passiveAvailable?: boolean;\n};\n\n// @needsAudit\n/**\n * Type of the object containing heading details and provided by `watchHeadingAsync` callback.\n */\nexport type LocationHeadingObject = {\n  /**\n   * Measure of true north in degrees (needs location permissions, will return `-1` if not given).\n   */\n  trueHeading: number;\n  /**\n   * Measure of magnetic north in degrees.\n   */\n  magHeading: number;\n  /**\n   * Level of calibration of compass.\n   * - `3`: high accuracy, `2`: medium accuracy, `1`: low accuracy, `0`: none\n   * Reference for iOS:\n   * - `3`: < 20 degrees uncertainty, `2`: < 35 degrees, `1`: < 50 degrees, `0`: > 50 degrees\n   */\n  accuracy: number;\n};\n\n// @needsAudit\n/**\n * Represents `watchHeadingAsync` callback.\n */\nexport type LocationHeadingCallback = (location: LocationHeadingObject) => any;\n\n// @needsAudit\n/**\n * An object of options for forward and reverse geocoding.\n */\nexport type LocationGeocodingOptions = {\n  /**\n   * Whether to force using Google Maps API instead of the native implementation.\n   * Used by default only on Web platform. Requires providing an API key by `setGoogleApiKey`.\n   */\n  useGoogleMaps?: boolean;\n};\n\n// @needsAudit\n/**\n * Type representing a result of `geocodeAsync`.\n */\nexport type LocationGeocodedLocation = {\n  /**\n   * The latitude in degrees.\n   */\n  latitude: number;\n  /**\n   * The longitude in degrees.\n   */\n  longitude: number;\n  /**\n   * The altitude in meters above the WGS 84 reference ellipsoid.\n   */\n  altitude?: number;\n  /**\n   * The radius of uncertainty for the location, measured in meters.\n   */\n  accuracy?: number;\n};\n\n// @needsAudit\n/**\n * Type representing a result of `reverseGeocodeAsync`.\n */\nexport type LocationGeocodedAddress = {\n  /**\n   * City name of the address.\n   */\n  city: string | null;\n  /**\n   * Additional city-level information like district name.\n   */\n  district: string | null;\n  /**\n   * Street number of the address.\n   */\n  streetNumber: string | null;\n  /**\n   * Street name of the address.\n   */\n  street: string | null;\n  /**\n   * The state or province associated with the address.\n   */\n  region: string | null;\n  /**\n   * Additional information about administrative area.\n   */\n  subregion: string | null;\n  /**\n   * Localized country name of the address.\n   */\n  country: string | null;\n  /**\n   * Postal code of the address.\n   */\n  postalCode: string | null;\n  /**\n   * The name of the placemark, for example, \"Tower Bridge\".\n   */\n  name: string | null;\n  /**\n   * Localized (ISO) country code of the address, if available.\n   */\n  isoCountryCode: string | null;\n  /**\n   * The timezone identifier associated with the address.\n   * @platform ios\n   */\n  timezone: string | null;\n};\n\n// @needsAudit\n/**\n * Represents subscription object returned by methods watching for new locations or headings.\n */\nexport type LocationSubscription = {\n  /**\n   * Call this function with no arguments to remove this subscription. The callback will no longer\n   * be called for location updates.\n   */\n  remove: () => void;\n};\n\n// @needsAudit\nexport type PermissionDetailsLocationIOS = {\n  /**\n   * The scope of granted permission. Indicates when it's possible to use location.\n   */\n  scope: 'whenInUse' | 'always' | 'none';\n};\n\n// @needsAudit\nexport type PermissionDetailsLocationAndroid = {\n  /**\n   * @deprecated Use `accuracy` field instead.\n   */\n  scope: 'fine' | 'coarse' | 'none';\n  /**\n   * Indicates the type of location provider.\n   */\n  accuracy: 'fine' | 'coarse' | 'none';\n};\n\n// @needsAudit\n/**\n * `LocationPermissionResponse` extends [PermissionResponse](#permissionresponse)\n * type exported by `expo-modules-core` and contains additional platform-specific fields.\n */\nexport type LocationPermissionResponse = PermissionResponse & {\n  ios?: PermissionDetailsLocationIOS;\n  android?: PermissionDetailsLocationAndroid;\n};\n\nexport type { PermissionResponse };\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/LocationEventEmitter.d.ts b/node_modules/expo-location/build/LocationEventEmitter.d.ts
deleted file mode 100644
index a96bb04..0000000
--- a/node_modules/expo-location/build/LocationEventEmitter.d.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-import { EventEmitter } from 'expo-modules-core';
-export declare const LocationEventEmitter: EventEmitter;
-//# sourceMappingURL=LocationEventEmitter.d.ts.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/LocationEventEmitter.d.ts.map b/node_modules/expo-location/build/LocationEventEmitter.d.ts.map
deleted file mode 100644
index a2abea0..0000000
--- a/node_modules/expo-location/build/LocationEventEmitter.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"LocationEventEmitter.d.ts","sourceRoot":"","sources":["../src/LocationEventEmitter.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AAIjD,eAAO,MAAM,oBAAoB,cAAiC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/LocationEventEmitter.js b/node_modules/expo-location/build/LocationEventEmitter.js
deleted file mode 100644
index 0ceb70a..0000000
--- a/node_modules/expo-location/build/LocationEventEmitter.js
+++ /dev/null
@@ -1,4 +0,0 @@
-import { EventEmitter } from 'expo-modules-core';
-import ExpoLocation from './ExpoLocation';
-export const LocationEventEmitter = new EventEmitter(ExpoLocation);
-//# sourceMappingURL=LocationEventEmitter.js.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/LocationEventEmitter.js.map b/node_modules/expo-location/build/LocationEventEmitter.js.map
deleted file mode 100644
index bd42406..0000000
--- a/node_modules/expo-location/build/LocationEventEmitter.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"LocationEventEmitter.js","sourceRoot":"","sources":["../src/LocationEventEmitter.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AAEjD,OAAO,YAAY,MAAM,gBAAgB,CAAC;AAE1C,MAAM,CAAC,MAAM,oBAAoB,GAAG,IAAI,YAAY,CAAC,YAAY,CAAC,CAAC","sourcesContent":["import { EventEmitter } from 'expo-modules-core';\n\nimport ExpoLocation from './ExpoLocation';\n\nexport const LocationEventEmitter = new EventEmitter(ExpoLocation);\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/LocationEventEmitter.web.d.ts b/node_modules/expo-location/build/LocationEventEmitter.web.d.ts
deleted file mode 100644
index 49ee4d3..0000000
--- a/node_modules/expo-location/build/LocationEventEmitter.web.d.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-import { EventEmitter } from 'expo-modules-core';
-export declare const LocationEventEmitter: EventEmitter;
-//# sourceMappingURL=LocationEventEmitter.web.d.ts.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/LocationEventEmitter.web.d.ts.map b/node_modules/expo-location/build/LocationEventEmitter.web.d.ts.map
deleted file mode 100644
index 9710684..0000000
--- a/node_modules/expo-location/build/LocationEventEmitter.web.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"LocationEventEmitter.web.d.ts","sourceRoot":"","sources":["../src/LocationEventEmitter.web.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AAEjD,eAAO,MAAM,oBAAoB,cAA8B,CAAC"}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/LocationEventEmitter.web.js b/node_modules/expo-location/build/LocationEventEmitter.web.js
deleted file mode 100644
index db27091..0000000
--- a/node_modules/expo-location/build/LocationEventEmitter.web.js
+++ /dev/null
@@ -1,3 +0,0 @@
-import { EventEmitter } from 'expo-modules-core';
-export const LocationEventEmitter = new EventEmitter({});
-//# sourceMappingURL=LocationEventEmitter.web.js.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/LocationEventEmitter.web.js.map b/node_modules/expo-location/build/LocationEventEmitter.web.js.map
deleted file mode 100644
index a5289a1..0000000
--- a/node_modules/expo-location/build/LocationEventEmitter.web.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"LocationEventEmitter.web.js","sourceRoot":"","sources":["../src/LocationEventEmitter.web.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AAEjD,MAAM,CAAC,MAAM,oBAAoB,GAAG,IAAI,YAAY,CAAC,EAAS,CAAC,CAAC","sourcesContent":["import { EventEmitter } from 'expo-modules-core';\n\nexport const LocationEventEmitter = new EventEmitter({} as any);\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/LocationSubscribers.d.ts b/node_modules/expo-location/build/LocationSubscribers.d.ts
deleted file mode 100644
index 4bcfa53..0000000
--- a/node_modules/expo-location/build/LocationSubscribers.d.ts
+++ /dev/null
@@ -1,30 +0,0 @@
-import { LocationCallback, LocationHeadingCallback } from './Location.types';
-type EventObject = {
-    watchId: number;
-    [key: string]: any;
-};
-declare class Subscriber<CallbackType extends LocationCallback | LocationHeadingCallback> {
-    private eventName;
-    private eventDataField;
-    private callbacks;
-    private eventSubscription;
-    constructor(eventName: string, eventDataField: string);
-    maybeInitializeSubscription(): void;
-    /**
-     * Registers given callback under new id which is then returned.
-     */
-    registerCallback(callback: CallbackType): number;
-    /**
-     * Unregisters a callback with given id and revokes the subscription if possible.
-     */
-    unregisterCallback(id: number): void;
-    trigger(event: EventObject): void;
-}
-export declare const LocationSubscriber: Subscriber<LocationCallback>;
-export declare const HeadingSubscriber: Subscriber<LocationHeadingCallback>;
-/**
- * @private Necessary for some unit tests.
- */
-export declare function _getCurrentWatchId(): number;
-export {};
-//# sourceMappingURL=LocationSubscribers.d.ts.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/LocationSubscribers.d.ts.map b/node_modules/expo-location/build/LocationSubscribers.d.ts.map
deleted file mode 100644
index c8a28fc..0000000
--- a/node_modules/expo-location/build/LocationSubscribers.d.ts.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"LocationSubscribers.d.ts","sourceRoot":"","sources":["../src/LocationSubscribers.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,gBAAgB,EAAE,uBAAuB,EAAE,MAAM,kBAAkB,CAAC;AAG7E,KAAK,WAAW,GAAG;IACjB,OAAO,EAAE,MAAM,CAAC;IAChB,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACpB,CAAC;AAIF,cAAM,UAAU,CAAC,YAAY,SAAS,gBAAgB,GAAG,uBAAuB;IAC9E,OAAO,CAAC,SAAS,CAAS;IAC1B,OAAO,CAAC,cAAc,CAAS;IAC/B,OAAO,CAAC,SAAS,CAAsC;IACvD,OAAO,CAAC,iBAAiB,CAA6B;gBAE1C,SAAS,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM;IAKrD,2BAA2B;IAU3B;;OAEG;IACH,gBAAgB,CAAC,QAAQ,EAAE,YAAY,GAAG,MAAM;IAOhD;;OAEG;IACH,kBAAkB,CAAC,EAAE,EAAE,MAAM,GAAG,IAAI;IAepC,OAAO,CAAC,KAAK,EAAE,WAAW,GAAG,IAAI;CAUlC;AAED,eAAO,MAAM,kBAAkB,8BAG9B,CAAC;AACF,eAAO,MAAM,iBAAiB,qCAG7B,CAAC;AAEF;;GAEG;AACH,wBAAgB,kBAAkB,IAAI,MAAM,CAE3C"}
\ No newline at end of file
diff --git a/node_modules/expo-location/build/LocationSubscribers.js b/node_modules/expo-location/build/LocationSubscribers.js
deleted file mode 100644
index 0dc0812..0000000
--- a/node_modules/expo-location/build/LocationSubscribers.js
+++ /dev/null
@@ -1,62 +0,0 @@
-import ExpoLocation from './ExpoLocation';
-import { LocationEventEmitter } from './LocationEventEmitter';
-let nextWatchId = 0;
-class Subscriber {
-    eventName;
-    eventDataField;
-    callbacks = {};
-    eventSubscription = null;
-    constructor(eventName, eventDataField) {
-        this.eventName = eventName;
-        this.eventDataField = eventDataField;
-    }
-    maybeInitializeSubscription() {
-        if (this.eventSubscription) {
-            return;
-        }
-        this.eventSubscription = LocationEventEmitter.addListener(this.eventName, (event) => this.trigger(event));
-    }
-    /**
-     * Registers given callback under new id which is then returned.
-     */
-    registerCallback(callback) {
-        this.maybeInitializeSubscription();
-        const id = ++nextWatchId;
-        this.callbacks[id] = callback;
-        return id;
-    }
-    /**
-     * Unregisters a callback with given id and revokes the subscription if possible.
-     */
-    unregisterCallback(id) {
-        // Do nothing if we have already unregistered the callback.
-        if (!this.callbacks[id]) {
-            return;
-        }
-        delete this.callbacks[id];
-        ExpoLocation.removeWatchAsync(id);
-        if (Object.keys(this.callbacks).length === 0 && this.eventSubscription) {
-            LocationEventEmitter.removeSubscription(this.eventSubscription);
-            this.eventSubscription = null;
-        }
-    }
-    trigger(event) {
-        const watchId = event.watchId;
-        const callback = this.callbacks[watchId];
-        if (callback) {
-            callback(event[this.eventDataField]);
-        }
-        else {
-            ExpoLocation.removeWatchAsync(watchId);
-        }
-    }
-}
-export const LocationSubscriber = new Subscriber('Expo.locationChanged', 'location');
-export const HeadingSubscriber = new Subscriber('Expo.headingChanged', 'heading');
-/**
- * @private Necessary for some unit tests.
- */
-export function _getCurrentWatchId() {
-    return nextWatchId;
-}
-//# sourceMappingURL=LocationSubscribers.js.map
\ No newline at end of file
diff --git a/node_modules/expo-location/build/LocationSubscribers.js.map b/node_modules/expo-location/build/LocationSubscribers.js.map
deleted file mode 100644
index a68c3ac..0000000
--- a/node_modules/expo-location/build/LocationSubscribers.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"LocationSubscribers.js","sourceRoot":"","sources":["../src/LocationSubscribers.ts"],"names":[],"mappings":"AAEA,OAAO,YAAY,MAAM,gBAAgB,CAAC;AAE1C,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAO9D,IAAI,WAAW,GAAG,CAAC,CAAC;AAEpB,MAAM,UAAU;IACN,SAAS,CAAS;IAClB,cAAc,CAAS;IACvB,SAAS,GAAmC,EAAE,CAAC;IAC/C,iBAAiB,GAAwB,IAAI,CAAC;IAEtD,YAAY,SAAiB,EAAE,cAAsB;QACnD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IACvC,CAAC;IAED,2BAA2B;QACzB,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC1B,OAAO;SACR;QACD,IAAI,CAAC,iBAAiB,GAAG,oBAAoB,CAAC,WAAW,CACvD,IAAI,CAAC,SAAS,EACd,CAAC,KAAkB,EAAE,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAC5C,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,gBAAgB,CAAC,QAAsB;QACrC,IAAI,CAAC,2BAA2B,EAAE,CAAC;QACnC,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC;QACzB,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC;QAC9B,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;OAEG;IACH,kBAAkB,CAAC,EAAU;QAC3B,2DAA2D;QAC3D,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE;YACvB,OAAO;SACR;QAED,OAAO,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;QAC1B,YAAY,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC;QAElC,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,iBAAiB,EAAE;YACtE,oBAAoB,CAAC,kBAAkB,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;YAChE,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;SAC/B;IACH,CAAC;IAED,OAAO,CAAC,KAAkB;QACxB,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;QAC9B,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QAEzC,IAAI,QAAQ,EAAE;YACZ,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;SACtC;aAAM;YACL,YAAY,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;SACxC;IACH,CAAC;CACF;AAED,MAAM,CAAC,MAAM,kBAAkB,GAAG,IAAI,UAAU,CAC9C,sBAAsB,EACtB,UAAU,CACX,CAAC;AACF,MAAM,CAAC,MAAM,iBAAiB,GAAG,IAAI,UAAU,CAC7C,qBAAqB,EACrB,SAAS,CACV,CAAC;AAEF;;GAEG;AACH,MAAM,UAAU,kBAAkB;IAChC,OAAO,WAAW,CAAC;AACrB,CAAC","sourcesContent":["import { Subscription } from 'expo-modules-core';\n\nimport ExpoLocation from './ExpoLocation';\nimport { LocationCallback, LocationHeadingCallback } from './Location.types';\nimport { LocationEventEmitter } from './LocationEventEmitter';\n\ntype EventObject = {\n  watchId: number;\n  [key: string]: any;\n};\n\nlet nextWatchId = 0;\n\nclass Subscriber<CallbackType extends LocationCallback | LocationHeadingCallback> {\n  private eventName: string;\n  private eventDataField: string;\n  private callbacks: { [id: string]: CallbackType } = {};\n  private eventSubscription: Subscription | null = null;\n\n  constructor(eventName: string, eventDataField: string) {\n    this.eventName = eventName;\n    this.eventDataField = eventDataField;\n  }\n\n  maybeInitializeSubscription() {\n    if (this.eventSubscription) {\n      return;\n    }\n    this.eventSubscription = LocationEventEmitter.addListener(\n      this.eventName,\n      (event: EventObject) => this.trigger(event)\n    );\n  }\n\n  /**\n   * Registers given callback under new id which is then returned.\n   */\n  registerCallback(callback: CallbackType): number {\n    this.maybeInitializeSubscription();\n    const id = ++nextWatchId;\n    this.callbacks[id] = callback;\n    return id;\n  }\n\n  /**\n   * Unregisters a callback with given id and revokes the subscription if possible.\n   */\n  unregisterCallback(id: number): void {\n    // Do nothing if we have already unregistered the callback.\n    if (!this.callbacks[id]) {\n      return;\n    }\n\n    delete this.callbacks[id];\n    ExpoLocation.removeWatchAsync(id);\n\n    if (Object.keys(this.callbacks).length === 0 && this.eventSubscription) {\n      LocationEventEmitter.removeSubscription(this.eventSubscription);\n      this.eventSubscription = null;\n    }\n  }\n\n  trigger(event: EventObject): void {\n    const watchId = event.watchId;\n    const callback = this.callbacks[watchId];\n\n    if (callback) {\n      callback(event[this.eventDataField]);\n    } else {\n      ExpoLocation.removeWatchAsync(watchId);\n    }\n  }\n}\n\nexport const LocationSubscriber = new Subscriber<LocationCallback>(\n  'Expo.locationChanged',\n  'location'\n);\nexport const HeadingSubscriber = new Subscriber<LocationHeadingCallback>(\n  'Expo.headingChanged',\n  'heading'\n);\n\n/**\n * @private Necessary for some unit tests.\n */\nexport function _getCurrentWatchId(): number {\n  return nextWatchId;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-location/plugin/build/withLocation.d.ts b/node_modules/expo-location/plugin/build/withLocation.d.ts
deleted file mode 100644
index 3fb6d7f..0000000
--- a/node_modules/expo-location/plugin/build/withLocation.d.ts
+++ /dev/null
@@ -1,9 +0,0 @@
-import { ConfigPlugin } from 'expo/config-plugins';
-declare const _default: ConfigPlugin<void | {
-    locationAlwaysAndWhenInUsePermission?: string | undefined;
-    locationAlwaysPermission?: string | undefined;
-    locationWhenInUsePermission?: string | undefined;
-    isIosBackgroundLocationEnabled?: boolean | undefined;
-    isAndroidBackgroundLocationEnabled?: boolean | undefined;
-}>;
-export default _default;
diff --git a/node_modules/expo-location/plugin/build/withLocation.js b/node_modules/expo-location/plugin/build/withLocation.js
deleted file mode 100644
index 917f3b0..0000000
--- a/node_modules/expo-location/plugin/build/withLocation.js
+++ /dev/null
@@ -1,44 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-const config_plugins_1 = require("expo/config-plugins");
-const pkg = require('expo-location/package.json');
-const LOCATION_USAGE = 'Allow $(PRODUCT_NAME) to access your location';
-const withBackgroundLocation = (config) => {
-    return (0, config_plugins_1.withInfoPlist)(config, (config) => {
-        if (!Array.isArray(config.modResults.UIBackgroundModes)) {
-            config.modResults.UIBackgroundModes = [];
-        }
-        if (!config.modResults.UIBackgroundModes.includes('location')) {
-            config.modResults.UIBackgroundModes.push('location');
-        }
-        return config;
-    });
-};
-const withLocation = (config, { locationAlwaysAndWhenInUsePermission, locationAlwaysPermission, locationWhenInUsePermission, isIosBackgroundLocationEnabled, isAndroidBackgroundLocationEnabled, } = {}) => {
-    if (isIosBackgroundLocationEnabled) {
-        config = withBackgroundLocation(config);
-    }
-    config = (0, config_plugins_1.withInfoPlist)(config, (config) => {
-        config.modResults.NSLocationAlwaysAndWhenInUseUsageDescription =
-            locationAlwaysAndWhenInUsePermission ||
-                config.modResults.NSLocationAlwaysAndWhenInUseUsageDescription ||
-                LOCATION_USAGE;
-        config.modResults.NSLocationAlwaysUsageDescription =
-            locationAlwaysPermission ||
-                config.modResults.NSLocationAlwaysUsageDescription ||
-                LOCATION_USAGE;
-        config.modResults.NSLocationWhenInUseUsageDescription =
-            locationWhenInUsePermission ||
-                config.modResults.NSLocationWhenInUseUsageDescription ||
-                LOCATION_USAGE;
-        return config;
-    });
-    return config_plugins_1.AndroidConfig.Permissions.withPermissions(config, [
-        'android.permission.ACCESS_COARSE_LOCATION',
-        'android.permission.ACCESS_FINE_LOCATION',
-        'android.permission.FOREGROUND_SERVICE',
-        // Optional
-        isAndroidBackgroundLocationEnabled && 'android.permission.ACCESS_BACKGROUND_LOCATION',
-    ].filter(Boolean));
-};
-exports.default = (0, config_plugins_1.createRunOncePlugin)(withLocation, pkg.name, pkg.version);
diff --git a/node_modules/expo-location/src/__tests__/Location-test.native.ts b/node_modules/expo-location/src/__tests__/Location-test.native.ts
new file mode 100755
index 0000000..118357e
--- /dev/null
+++ b/node_modules/expo-location/src/__tests__/Location-test.native.ts
@@ -0,0 +1,149 @@
+import { NativeModulesProxy, Platform } from 'expo-modules-core';
+import { mockProperty, unmockAllProperties } from 'jest-expo';
+
+import * as Location from '../Location';
+
+const fakeReturnValue = {
+  coords: {
+    latitude: 1,
+    longitude: 2,
+    altitude: 3,
+    accuracy: 4,
+    heading: 5,
+    speed: 6,
+  },
+  timestamp: 7,
+};
+
+function applyMocks() {
+  mockProperty(
+    NativeModulesProxy.ExpoLocation,
+    'getCurrentPositionAsync',
+    jest.fn(async () => fakeReturnValue)
+  );
+  mockProperty(
+    NativeModulesProxy.ExpoLocation,
+    'requestPermissionsAsync',
+    jest.fn(async () => {})
+  );
+}
+
+beforeAll(() => {
+  Location.installWebGeolocationPolyfill();
+});
+
+beforeEach(() => {
+  applyMocks();
+});
+
+afterEach(() => {
+  unmockAllProperties();
+});
+
+it(`getCurrentPositionAsync works`, async () => {
+  const result = await Location.getCurrentPositionAsync({});
+  expect(result).toEqual(fakeReturnValue);
+});
+
+describe('watchPositionAsync', () => {
+  it(`receives repeated events`, async () => {
+    let resolveBarrier;
+    const callback = jest.fn();
+    const watchBarrier = new Promise((resolve) => {
+      resolveBarrier = resolve;
+    });
+    mockProperty(
+      NativeModulesProxy.ExpoLocation,
+      'watchPositionImplAsync',
+      jest.fn(resolveBarrier)
+    );
+    await Location.watchPositionAsync({}, callback);
+    await watchBarrier;
+
+    emitNativeLocationUpdate(fakeReturnValue);
+    emitNativeLocationUpdate(fakeReturnValue);
+    expect(callback).toHaveBeenCalledTimes(2);
+  });
+});
+
+if (Platform.OS === 'android') {
+  xdescribe('geocodeAsync', () => {
+    // TODO(@tsapeta): This doesn't work due to missing Google Maps API key.
+    it(`falls back to Google Maps API on Android without Google Play services`, () => {
+      mockProperty(NativeModulesProxy.ExpoLocation, 'geocodeAsync', async () => {
+        const error = new Error();
+        (error as any).code = 'E_NO_GEOCODER';
+        throw error;
+      });
+      return expect(Location.geocodeAsync('Googleplex')).rejects.toMatchObject({
+        code: 'E_NO_GEOCODER',
+      });
+    });
+  });
+}
+
+describe('reverseGeocodeAsync', () => {
+  it(`rejects non-numeric latitude/longitude`, () => {
+    // We need to cast these latitude/longitude strings to any type, so TypeScript diagnostics will pass here.
+    return expect(
+      Location.reverseGeocodeAsync({ latitude: '37.7' as any, longitude: '-122.5' as any })
+    ).rejects.toEqual(expect.any(TypeError));
+  });
+});
+
+describe('navigator.geolocation polyfill', () => {
+  beforeEach(() => {
+    applyMocks();
+  });
+
+  afterEach(() => {
+    unmockAllProperties();
+  });
+
+  describe('getCurrentPosition', () => {
+    it(`delegates to getCurrentPositionAsync`, async () => {
+      let pass;
+      const barrier = new Promise((resolve) => {
+        pass = resolve;
+      });
+      navigator.geolocation.getCurrentPosition(pass, pass, {});
+      await barrier;
+      expect(NativeModulesProxy.ExpoLocation.getCurrentPositionAsync).toHaveBeenCalled();
+    });
+  });
+
+  describe('watchPosition', () => {
+    it(`watches for updates and stops when clearWatch is called`, async () => {
+      let resolveBarrier;
+      const watchBarrier = new Promise((resolve) => {
+        resolveBarrier = resolve;
+      });
+      mockProperty(
+        NativeModulesProxy.ExpoLocation,
+        'watchPositionImplAsync',
+        jest.fn(async () => {
+          resolveBarrier();
+        })
+      );
+      const callback = jest.fn();
+
+      const watchId = navigator.geolocation.watchPosition(callback);
+      await watchBarrier;
+
+      emitNativeLocationUpdate(fakeReturnValue);
+      emitNativeLocationUpdate(fakeReturnValue);
+      expect(callback).toHaveBeenCalledTimes(2);
+
+      navigator.geolocation.clearWatch(watchId);
+      emitNativeLocationUpdate(fakeReturnValue);
+      expect(callback).toHaveBeenCalledTimes(2);
+    });
+  });
+});
+
+function emitNativeLocationUpdate(location) {
+  Location.EventEmitter.emit('Expo.locationChanged', {
+    watchId: Location._getCurrentWatchId(),
+    location,
+  });
+}
